<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向宇的博客 | Xiang Yu&#39;s Blog</title>
  
  <subtitle>Hello World, Hello Programming!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kisky3.github.io/"/>
  <updated>2021-09-24T15:33:55.997Z</updated>
  <id>https://kisky3.github.io/</id>
  
  <author>
    <name>Xiang Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NuxtMemo</title>
    <link href="https://kisky3.github.io/2021/09/25/NuxtMemo/"/>
    <id>https://kisky3.github.io/2021/09/25/NuxtMemo/</id>
    <published>2021-09-24T15:33:55.000Z</published>
    <updated>2021-09-24T15:33:55.997Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Foward Proxy and Reverse Proxy</title>
    <link href="https://kisky3.github.io/2021/09/15/fowardproxyandreverseproxy/"/>
    <id>https://kisky3.github.io/2021/09/15/fowardproxyandreverseproxy/</id>
    <published>2021-09-15T14:11:01.000Z</published>
    <updated>2021-09-18T15:02:08.413Z</updated>
    
    <content type="html"><![CDATA[<p>关于正向代理和反向代理</p><a id="more"></a><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>什么是正向代理，</p><p>比如说你想要问A借钱，但是A不直接借给你。于是你通过中介B向A借到了钱。<br>这里的中介B就是一个非常重要的角色<code>代理</code>！</p><p>也可以说是正向代理。因为有B做中介，所以其实A是不知道最后是谁借了他的钱的。这点很重要！</p><p>我们常说的代理就是这样的正向代理。它隐藏了真实的用户请求(相当于借钱的你)。服务器(A)不知道真正的客户端是谁。因为中间存在一个代理服务器(B),它来代替客户端向服务器发送请求(借钱),再将返回的回应(借到的钱)返回给客户端。(把钱给你)</p><p>举个例子的话，<br>就相当于你在国内无法上twitter，但是你如果在海外搭建一个正向代理服务器，它代替你发送请求，再把请求返回给你,你就可以在国内自由twitter了。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理就像你打电话给A借钱。(对又是借钱)<br>但是A请了一个客服公司来处理借钱事务。这次呢接线员B、C、D、E ….都有可能接到你的电话，并且为你处理你的借钱请求。</p><p>这就是反向代理，也就是说你是不知道谁是为你服务的人。</p><p>也就是说反向代理隐藏了真实的服务器，当我们向服务器发送请求的时候，其实是向反向代理服务器发送请求。然后反向服务器会帮我们把真实请求发送到真实的服务器那里。</p><p>Nginx就是很好的反向代理服务器，经常用来做负载均衡。</p><p>这两者的区别在于: 代理的对象不一样。</p><p>正向代理代理的对象是客户端。<br>反向代理的对象是服务器端。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于正向代理和反向代理&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="Foward Proxy" scheme="https://kisky3.github.io/tags/Foward-Proxy/"/>
    
      <category term="Reverse Proxy" scheme="https://kisky3.github.io/tags/Reverse-Proxy/"/>
    
      <category term="正向代理" scheme="https://kisky3.github.io/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="https://kisky3.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Basic and Create a Reverse Proxy Server With Docker</title>
    <link href="https://kisky3.github.io/2021/08/16/NginxReverseProxyServer/"/>
    <id>https://kisky3.github.io/2021/08/16/NginxReverseProxyServer/</id>
    <published>2021-08-16T00:17:28.000Z</published>
    <updated>2021-09-18T15:02:08.091Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx的基础以及用Docker创建一个Nginx反向代理服务器</p><a id="more"></a><p>这篇文章是用于介绍Ngin的基本知识，<br>主要包括Nginx的启动,停止,以及如何使用Nginx和Docker来搭建一个反向代理服务器。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>请自己在系统里安装好Nginx,详细请参照<a href="https://runebook.dev/ja/docs/nginx/install" target="_blank" rel="noopener">Nginx的安装</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx的基础以及用Docker创建一个Nginx反向代理服务器&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="Nginx" scheme="https://kisky3.github.io/tags/Nginx/"/>
    
      <category term="Reverse Proxy Server" scheme="https://kisky3.github.io/tags/Reverse-Proxy-Server/"/>
    
  </entry>
  
  <entry>
    <title>Go and gRPC</title>
    <link href="https://kisky3.github.io/2021/07/02/createAPIwithLambdaGo/"/>
    <id>https://kisky3.github.io/2021/07/02/createAPIwithLambdaGo/</id>
    <published>2021-07-02T13:25:00.000Z</published>
    <updated>2021-09-18T15:02:08.266Z</updated>
    
    <content type="html"><![CDATA[<p>Go 和 gRPC的入门尝试</p><a id="more"></a><h3 id="Go是什么"><a href="#Go是什么" class="headerlink" title="Go是什么"></a>Go是什么</h3><p>Go语言是Google社内开发的一个开源编程语言。<br>Go的优点是对初学者友好,处理速度快,所需代码量少,有丰富的库以及插件,还可以进行并发处理,安全性高。<br>Go的缺点是情报较少,不支持Generics,没有例外处理,代码无法进行继承。</p><h3 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h3><p>gRPC是由Google公司开源的一款高性能的远程过程调用(RPC)框架，可以在任何环境下运行。该框架提供了负载均衡，跟踪，智能监控，身份验证等功能，可以实现系统间的高效连接。</p><h5 id="※RPC"><a href="#※RPC" class="headerlink" title="※RPC"></a>※RPC</h5><p>Remote Procedure Call的简称，翻译成中文就是远程过程调用。<br>也就是说两台服务器A,B,一个应用部署在A服务器上,想要调用B服务器上应用提供的函数/方法,由于不在一个内存空间,不能直接调用,需要通过网络来表达调用的语义和传达调用的数据。</p><h3 id="什么是Protocol-Buffers"><a href="#什么是Protocol-Buffers" class="headerlink" title="什么是Protocol Buffers"></a>什么是Protocol Buffers</h3><p>Protocol Buffers是Google开源的一个语言无关、平台无关的通信协议，其小巧、高效和友好的兼容性设计，使其被广泛使用。</p><h3 id="使用Go来玩玩gRPC"><a href="#使用Go来玩玩gRPC" class="headerlink" title="使用Go来玩玩gRPC"></a>使用Go来玩玩gRPC</h3><p>grpc.io提供的Go来玩一下gRPC.根据指导来.<br>首先确认一下Go的版本,需要Go1.6以上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.12.6 darwin/amd64</span><br></pre></td></tr></table></figure><p>安装gRPC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br><span class="line"></span><br><span class="line">$ cat $GOPATH/src/google.golang.org/grpc/version.go | grep Version</span><br><span class="line">// Version is the current grpc version.</span><br><span class="line">const Version = &quot;1.23.0-dev&quot;</span><br></pre></td></tr></table></figure><p>下载Protocol Buffers v3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew install protobuf</span><br><span class="line"></span><br><span class="line">$ protoc --version</span><br><span class="line">libprotoc 3.7.1</span><br></pre></td></tr></table></figure><p>下载Protocol Buffers的Go插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>Protocol Buffers文件(.proto)里定义service和message<br>在说明service和service里的rpc方法(也叫做service message)之前先说明一下gRPC能够定义的4种方法。</p><ul><li><ol><li>Simple RPC<br>gRPC客户端发送的单一消息到gRPC服务器,服务器再返回单一消息。(和tutorial的<code>GetFeature</code>相当)</li></ol></li><li><ol start="2"><li>Server side Streaming RPC<br>当gRPC客户端发来单一消息的时候gRPC服务器从流式返回多条消息。(和tutorial的<code>ListFeatures</code>相当)</li></ol></li><li><ol start="3"><li>Client side Streaming RPC<br>当gRPC客户端发来多条消息的时候gRPC服务器返回单一消息。(和tutorial的<code>RecordRoute</code>相当)</li></ol></li><li><ol start="4"><li>双向 Streaming RPC<br>当gRPC客户端发来多条消息的时候gRPC服务器从流式返回多条消息。(和tutorial的<code>RouteChat</code>相当)</li></ol></li></ul><p>※ Steaming(串流)</p><blockquote><p>串流技术，就是通过网路实时压缩和传输影音的技术。好处就是你不需要把完整的多媒体资料下载完后才能观看，而是像”水流”一样源源不断实时从发布源传到客户端。经过串流技术处理的、可以实时播放的多媒体有一个耳熟能详的名字，叫流媒体。</p></blockquote><p>那我们就根据上面的种类来定义service和service method。<br>tutorial定义的是<code>route_guide.proto</code></p><p>可以理解为「gRPC客户端发送的Request = service methord的参数」而「gPRC服务器返回的Response = service methord的返回值」，当使用service methord的Streaming的时候需要在参数和返回值之前加上<code>stream</code>声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">  rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br><span class="line">  rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br><span class="line">  rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line">  rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以定义message,使用service methord来定义所使用的message的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">message Point &#123;</span><br><span class="line">  int32 latitude = 1;</span><br><span class="line">  int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Rectangle &#123;</span><br><span class="line">  Point lo = 1;</span><br><span class="line">  Point hi = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Feature &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">  Point location = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteNote &#123;</span><br><span class="line">  Point location = 1;</span><br><span class="line">  string message = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">  int32 point_count = 1;</span><br><span class="line">  int32 feature_count = 2;</span><br><span class="line">  int32 distance = 3;</span><br><span class="line">  int32 elapsed_time = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Protocol Buffers文件（.proto） 能够自动生成Go文件（.pb.go).</p><p>Protocol Buffers文件编译之后，将会自动生成Go文件，该文件包括gRPC客户端代码和已经编译好的gRPC服务端的接口。</p><p>执行<code>protoc</code>命令行的话将会根据<code>route_guide.proto</code>里的定义自动生成<code>route_guide.pb.go</code>。</p><p>根据<code>--proto_path</code>来指定编译对象的Protocol Buffers文件路径,<code>--go_out</code>来指定自动生成的Go文件的输出路径(为了将gRPC设置成插件，要记得定义好plugins=grpc).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --proto_path routeguide/ routeguide/route_guide.proto --go_out=plugins=grpc:routeguide</span><br></pre></td></tr></table></figure><p>自动生成的Go文件(route_guide.pb.go)包含下面的东西。</p><h4 id="①-针对定义好的message的生成的构造体"><a href="#①-针对定义好的message的生成的构造体" class="headerlink" title="①.针对定义好的message的生成的构造体"></a>①.针对定义好的message的生成的构造体</h4><p>在构造体内也包含着对数据进行操作的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123;</span><br><span class="line">Latitude             int32    `protobuf:&quot;varint,1,opt,name=latitude,proto3&quot; json:&quot;latitude,omitempty&quot;`</span><br><span class="line">Longitude            int32    `protobuf:&quot;varint,2,opt,name=longitude,proto3&quot; json:&quot;longitude,omitempty&quot;`</span><br><span class="line">XXX_NoUnkeyedLiteral struct&#123;&#125; `json:&quot;-&quot;`</span><br><span class="line">XXX_unrecognized     []byte   `json:&quot;-&quot;`</span><br><span class="line">XXX_sizecache        int32    `json:&quot;-&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Point) GetLatitude() int32 &#123;</span><br><span class="line">if m != nil &#123;</span><br><span class="line">return m.Latitude</span><br><span class="line">&#125;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Point) GetLongitude() int32 &#123;</span><br><span class="line">if m != nil &#123;</span><br><span class="line">return m.Longitude</span><br><span class="line">&#125;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-呼出service-methord的gRPC客户端代码"><a href="#②-呼出service-methord的gRPC客户端代码" class="headerlink" title="②.呼出service methord的gRPC客户端代码"></a>②.呼出service methord的gRPC客户端代码</h4><p>以下是用于返回gRPC客户端的接口和各种处理的客户端的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type RouteGuideClient interface &#123;</span><br><span class="line">GetFeature(ctx context.Context, in *Point, opts ...grpc.CallOption) (*Feature, error)</span><br><span class="line">ListFeatures(ctx context.Context, in *Rectangle, opts ...grpc.CallOption) (RouteGuide_ListFeaturesClient, error)</span><br><span class="line">RecordRoute(ctx context.Context, opts ...grpc.CallOption) (RouteGuide_RecordRouteClient, error)</span><br><span class="line">RouteChat(ctx context.Context, opts ...grpc.CallOption) (RouteGuide_RouteChatClient, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type routeGuideClient struct &#123;</span><br><span class="line">cc *grpc.ClientConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewRouteGuideClient(cc *grpc.ClientConn) RouteGuideClient &#123;</span><br><span class="line">return &amp;routeGuideClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是利用上面的接口来便携的用于呼出service methord <code>GetFeature</code>的方法.<code>c.cc.Invoke</code>的第二参数是gPRC的service methord的endpoint.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (c *routeGuideClient) GetFeature(ctx context.Context, in *Point, opts ...grpc.CallOption) (*Feature, error) &#123;</span><br><span class="line">out := new(Feature)</span><br><span class="line">err := c.cc.Invoke(ctx, &quot;/routeguide.RouteGuide/GetFeature&quot;, in, out, opts...)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return out, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是呼出simple RPC service methord的<code>GetFeatuer</code>的简单的例子.如果涉及到串流的话可能写法会有一些不同.比如我们来看看双向串流的RPC的<code>RouteChat</code>的客户端代码.</p><p>因为是呼出双向串流的RPC的<code>RouteChat</code>的代码，所以service methord的呼出结果(来自gRPC服务器的response)是串流所接收的结果。</p><p>下面我们可以来看看下面的客户端的代码,我们可以推断出：service methord的呼出结果的返回值<code>RouteGuide_RouteChatClient</code>是串流发送message的<code>Send</code>(gPRC客户端 =&gt; gRPC服务器)、串流用于接收message的<code>Recv</code>(gRPC服务器 =&gt; gRPC客户端)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (c *routeGuideClient) RouteChat(ctx context.Context, opts ...grpc.CallOption) (RouteGuide_RouteChatClient, error) &#123;</span><br><span class="line">stream, err := c.cc.NewStream(ctx, &amp;_RouteGuide_serviceDesc.Streams[2], &quot;/routeguide.RouteGuide/RouteChat&quot;, opts...)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">x := &amp;routeGuideRouteChatClient&#123;stream&#125;</span><br><span class="line">return x, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RouteGuide_RouteChatClient interface &#123;</span><br><span class="line">Send(*RouteNote) error</span><br><span class="line">Recv() (*RouteNote, error)</span><br><span class="line">grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type routeGuideRouteChatClient struct &#123;</span><br><span class="line">grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *routeGuideRouteChatClient) Send(m *RouteNote) error &#123;</span><br><span class="line">return x.ClientStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *routeGuideRouteChatClient) Recv() (*RouteNote, error) &#123;</span><br><span class="line">m := new(RouteNote)</span><br><span class="line">if err := x.ClientStream.RecvMsg(m); err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return m, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的是从gRPC服务器的response到gRPC客户端的串流接收为止.</p><h4 id="③-service-methord用的gRPC服务器用的接口"><a href="#③-service-methord用的gRPC服务器用的接口" class="headerlink" title="③.service methord用的gRPC服务器用的接口"></a>③.service methord用的gRPC服务器用的接口</h4><p>和客户端的代码不同,gRPC服务器是需要自己事先进行编写，所以只是包含了接口的定义.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type RouteGuideServer interface &#123;</span><br><span class="line">GetFeature(context.Context, *Point) (*Feature, error)</span><br><span class="line">ListFeatures(*Rectangle, RouteGuide_ListFeaturesServer) error</span><br><span class="line">RecordRoute(RouteGuide_RecordRouteServer) error</span><br><span class="line">RouteChat(RouteGuide_RouteChatServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>simple RPC的<code>GetFeature</code>的参数的类型是，Protocol Buffers文件的定义里包含的东西，所以和串流相关的service methord的参数是略微不同,我们来挖一挖双向串流RPC的<code>RouteChat</code>。</p><p><code>RouteChat</code>的参数<code>RouteGuide_RouteChatServer</code>如下，串流用于送行的<code>Send</code>(gRPC服务器 =&gt; gRPC客户端)和<code>Recv</code>(gRPC客户端 =&gt; gRPC服务器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type RouteGuide_RouteChatServer interface &#123;</span><br><span class="line">Send(*RouteNote) error</span><br><span class="line">Recv() (*RouteNote, error)</span><br><span class="line">grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type routeGuideRouteChatServer struct &#123;</span><br><span class="line">grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *routeGuideRouteChatServer) Send(m *RouteNote) error &#123;</span><br><span class="line">return x.ServerStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *routeGuideRouteChatServer) Recv() (*RouteNote, error) &#123;</span><br><span class="line">m := new(RouteNote)</span><br><span class="line">if err := x.ServerStream.RecvMsg(m); err != nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return m, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gRPC服务器的编写"><a href="#gRPC服务器的编写" class="headerlink" title="gRPC服务器的编写"></a>gRPC服务器的编写</h3><p>要编写gRPC服务器的话需要以下的工作:</p><ol><li>在自动生成的Go文件里添加gRPC服务器的接口.</li><li>从gRPC客户端的request到gRPC服务器送去request的处理.</li></ol><p>gRPC服务器的接口的编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type routeGuideServer struct &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 和 gRPC的入门尝试&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="GO" scheme="https://kisky3.github.io/tags/GO/"/>
    
      <category term="gPPC" scheme="https://kisky3.github.io/tags/gPPC/"/>
    
  </entry>
  
  <entry>
    <title>AWS CLF Lesson7〜10 Memo</title>
    <link href="https://kisky3.github.io/2021/06/26/lesson3/"/>
    <id>https://kisky3.github.io/2021/06/26/lesson3/</id>
    <published>2021-06-26T13:06:40.000Z</published>
    <updated>2021-09-18T15:02:08.490Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 云从业者基础知识 学习笔记7 〜 10</p><a id="more"></a><h3 id="7-ネットワークサービス"><a href="#7-ネットワークサービス" class="headerlink" title="7 ネットワークサービス"></a>7 ネットワークサービス</h3><p>VPCは隔離されたプライベートなネットワーク構成をお客様がコントロールできるサービス。</p><p>VPCはリージョンを選択して作成。<br>CIDRでVPCのプライベートIPアドレスの範囲を定義。</p><p>インターネットゲートウェイはVPCとパブリックインターネットを接続。<br>インターネットゲートウェイ自体が高可用性と冗長性を持っている。</p><p>ルートテーブルはサブネットと関連付ける。<br>サブネット内のリソースがどこに接続できるかを定義する。</p><p>サブネットは役割で分割する。<br>外部インターネットに接続できるのがパブリックサブネット。<br>外部インターネットに接続せず外部アクセスからリソースを保護できるのがプライベートサブネット。</p><p>セキュリティグループは、インスタンスに対してのトラフィックを制御する仮想ファイアウォール。<br>許可するインバウンドのポートと送信元を設定するボワイトリスト。<br>送信元には、CIDRか他のセキュリティグループIDを指定できる。</p><p>ネットワークACLは、サブネットに対してのトラフィックを制御する仮想ファイアウォール。<br>拒否するインバウンドのポートと送信元を設定するブラックリスト。<br>必要がなければ設定しない追加のセキュリティレイヤー。</p><p>外部からEC2インスタンスにアクセスするための重要なポイント</p><ul><li>インターネットゲートウェイをVPCにアタッチする。</li><li>インターネットゲートウェイへの経路を持つルートテーブルをサブネットに関連付ける。</li><li>EC2インスタンスをそのサブネット内で起動する。</li><li>EC2インスタンスにパブリックIPアドレスを有効にする(またはEC2のパブリックIPアドレスを固定するElastic IPをアタッチする)</li></ul><p>VPCと既存のオンプレミス環境をVPN接続できる。<br>VPCと既存のオンプレミス環境をダイレクトコネクトを使って専用線で接続できる。</p><p>CloudFrontはユーザーへ静的/動的ウェブコンテンツを配信するEdgeサービス。<br>エッジロケーションを使用するCDNサービス。<br>S3から直接に配信したり、ELB経由のEC2から配信するよりも、<br>CloudFrontにキャッシュを持ち、ユーザーにはキャッシュコンテンツを配信する方が、より早く効率的にコンテンツを提供できる。</p><p>世界中のエッジロケーションが利用できるので、ユーザーへは最もレイテンシーの低いエッジロケーションから配信される。<br>通信を保護するために証明書を設定できる。<br>外部の攻撃からも守ることができる。</p><p>Router53はエッジロケーションで使用されるDNSサービス。<br>複数のレコードを設定し、用途に応じで最適なルーティングを選択できる。<br>システムの高可用性を世界中のリージョンを使用して実現できる。</p><p>Zone Apexに対しても柔軟な設定ができ、高可用性を実現できる。</p><h3 id="8-データベースサービス"><a href="#8-データベースサービス" class="headerlink" title="8.データベースサービス"></a>8.データベースサービス</h3><p>RDS(Amazon Relational Database Service)オンプレミスで使われているデータベースエンジンをそのまま簡単に使うことができる。<br>RDSを使うことでインフラ管理から解放され、本来やるべき開発に注力できる。</p><p>OS、データベースエンジンのメンテナンスをAWSに任せることができる。</p><p>データベースのバックアップを管理しなくて良い。<br>バックアップ期間中の任意の特定時間のインスタンスを起動できる。</p><p>マルチAZ配置を使用することでデータベースの高可用性を実現できる。<br>レプリケーション、フェイルオーバーはRDSの機能によって自動的に行われる。</p><p>Amazon AuroraはMySQL/PostgreSQL互换の、クラウドに最適化されたリレーショナルデータベース。</p><p>DMS(AWS Database Migration Service)はデータベース間でデータを移行できるサービス。</p><p>DMSによりオンプレミスからAWSへの継続的なデータ移行を行い、システムのダウンロードタイムを最小限にできる。</p><p>DynamoDBは振るマネージドなデータベースサービス。<br>リージョンを選択して使うことができる。</p><p>データの特徴やシステム要件に応じで適したデータベースサービスを選択する。<br>中規模程度のアクセス量で、整合性や複雑なクエリを必要とする場合はRDSを選択する。<br>大規模なアクセス量で、単純な自由度の高いデータモデルを扱う場合はDynamoDBを選択する。</p><h3 id="9-管理サービス"><a href="#9-管理サービス" class="headerlink" title="9.管理サービス"></a>9.管理サービス</h3><p>AWSのサービスを使い始めると、サービスにより起動されたリソースのメトリクスがCloudWatchに自動的に収集され始める。</p><p>CloudWatchの特徴：</p><ul><li>標準(組み込み)メトリクスの収集、可視化</li><li>カスタムメトリクスの収集、可視化</li><li>ログの収集</li><li>アラーム</li></ul><p>標準メトリクスは、使用するサービスによって取得される情報が異なる。<br>EC2のカスタムメトリクスはCloudWatchエージェントで取得できる。</p><p>EC2のCloudWatchLogsはCloudWatchエージェントで取得できる。<br>CloudWatchLogsによりEC2をよりステートレスにできる。<br>CloudWatch Logsは文字列のフィルタリング結果をメトリクスとして扱える。</p><p>アラートを設定することにより、モニタリング結果に基づく運用を自動化できる。</p><p>Trusted Advisorはaws環境を自動でチェックして、ベストプラクティスに沿ったアドバイスをレポートする。</p><ul><li>コスト最適化</li><li>パフォーマンス</li><li>耐障害性</li><li>セキュリティ</li><li>サービス制限</li></ul><p>コスト最適化では、無駄なコストが発生していないかがチェックされる。</p><p>パフォーマンスでは、最適なサービス、サイズが選択されているかがチェックされる。</p><p>セキュリティでは、環境にリスクのある設定がないかがチェックされる。</p><p>フォールトトレランスでは、耐障害性が低い状態がないかがチェックされる。</p><p>意図しない操作や不正アクセスによってお客様に不利益が生じないよう、サービス制限がある。<br>サービス制限では、制限につかづいたサービスがアラート報告される。</p><p>CloudTrailはAWSアカウント内のすべてのAPIを呼び出しを記録します。<br>CloudFormationは、AWSの各リソースを含んだ環境を自動作成/更新/管理します。<br>Elastic Beanstalkは、Webアプリケーションの環境を簡単にAWSに構築します。</p><p>消費モデルはエンジニアだけではなく組織全体で受け入れる。</p><p>課金体制はサービスによって異なる。</p><p>お客様は最適な料金モデルを選択できる。</p><p>請求書では月の途中でも課金の状況を確認できる。</p><p>コスト配分タグによってROIの诉求分析ができる。</p><p>請求アラームによって使いすぎを抑止するための通知ができる。</p><p>AWS Organizationsで複数アカウントを階層管理できる。Organiationsの一括請求を使用することで、複数アカウントの請求を１つの請求にまとめることができます。</p><p>エスカレーションパスを用意することは重要。</p><p>4つのプランがあり、サポート料金によって段階がある。</p><p>簡易もつもりツールで、請求見込み額を事前に計算しておくことができる。</p><p>TCO計算ツールはAWSとオンプレミスのコストを比較するツール。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS 云从业者基础知识 学习笔记7 〜 10&lt;/p&gt;
    
    </summary>
    
    
      <category term="aws" scheme="https://kisky3.github.io/tags/aws/"/>
    
      <category term="AWS Certified Cloud Practitioner" scheme="https://kisky3.github.io/tags/AWS-Certified-Cloud-Practitioner/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Memo</title>
    <link href="https://kisky3.github.io/2021/06/22/leetcodememo/"/>
    <id>https://kisky3.github.io/2021/06/22/leetcodememo/</id>
    <published>2021-06-22T13:19:00.000Z</published>
    <updated>2021-09-18T15:02:08.473Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode笔记</p><a id="more"></a><p>刷LeetCode啊！！！</p><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>二分法最常见的是取到中位数。并且不断地根据中位数更新起点和终点，缩小范围到取得理想值。</p><p>一般来说首先设置start为1，end为数组最大位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="number">0</span>, <span class="keyword">const</span> end = array.length - <span class="number">1</span>(or something <span class="keyword">else</span>)</span><br></pre></td></tr></table></figure><p>然后取中点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start) / <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>通过while进行start和end的比较，直到start = end 然后结束处理。<br>进行中位数相关的条件判断, 将start或end重新代入。<br>最后在while结束循环的时候返回start。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">      <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start) / <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> (进行中位数相关的条件判断) &#123;</span><br><span class="line">        start = mid + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        end = mid</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure><h3 id="2-冒泡法"><a href="#2-冒泡法" class="headerlink" title="2.冒泡法"></a>2.冒泡法</h3><p>进行乱数数组排列的时候可以用冒泡法。(背下来～！)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><h3 id="3-取数列中的最大值"><a href="#3-取数列中的最大值" class="headerlink" title="3.取数列中的最大值"></a>3.取数列中的最大值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> piles = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...piles);</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://kisky3.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>iOS Input Zoom Issue</title>
    <link href="https://kisky3.github.io/2021/06/14/iosFormInputZoomIn/"/>
    <id>https://kisky3.github.io/2021/06/14/iosFormInputZoomIn/</id>
    <published>2021-06-14T13:50:53.000Z</published>
    <updated>2021-09-18T15:02:08.454Z</updated>
    
    <content type="html"><![CDATA[<p>iOS下的输入框点击放大问题</p><a id="more"></a><p>在iOS的表单输入的时候，经常会出现页面被强制扩大的问题。<br>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"select"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>吉田優子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>千代田桃<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>リリス<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>陽夏木ミカン<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="text"]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在表单里输入的话，就像下面这样，页面被扩大。<br><img src="./1.png" style="width:500px"></p><p>页面被扩大的原因是因为文字size没有达到16px的时候就会自动放大。</p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h3><p>将所有未满16px的文字size设置成16px;虽然在页面上看起来会大一点但是这个是最简单的解决方法了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="text"]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2:"></a>方法2:</h3><p>在将文字size设置成16px的同时，使用<code>transform的scale()</code>来使其看起来相对小。sccale()的值可以利用calc()来计算得到。<br>这个方法不仅要调整字体的大小，还要相应的调整位置和相对大小，有一点点麻烦。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="text"]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(calc(12 / 16));</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(calc(12 / 16));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3:"></a>方法3:</h3><p>viewport里设置<code>user-scalable=no</code>,user-scalable=no本来是使得用户无法自己扩大页面，以此来控制iOS的自动扩大问题。</p><p>本来是不推荐限制用户的操作的，但是在iOS10以后，<code>user-scalable=no</code>将不再生效啦。</p><p>也就是说可以满足用户在输入表单的时候不自动扩大，但是用户手动扩大是可行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><p>Android的话只写<code>user-scalable=no</code>是不起效的。要加入下面的js.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> isiOS = (ua.indexOf(<span class="string">'iphone'</span>) &gt; <span class="number">-1</span>) || (ua.indexOf(<span class="string">'ipad'</span>) &gt; <span class="number">-1</span>);</span></span><br><span class="line">if(isiOS) &#123;</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span></span><br><span class="line">  if(viewport) &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> viewportContent = viewport.getAttribute(<span class="string">'content'</span>);</span></span><br><span class="line"><span class="javascript">    viewport.setAttribute(<span class="string">'content'</span>, viewportContent + <span class="string">', user-scalable=no'</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://qiita.com/skwbr/items/b285cc312587c73a4812" target="_blank" rel="noopener">iOSでinputのフォーカス時に画面がズームするのを防ぐ – Qiita</a></p><p><a href="https://qiita.com/GreenDolphin/items/d74e5758a36478fbc039" target="_blank" rel="noopener">iOS10のSafariでuser-scalable=no が効かなくズームがされる問題への対策 – Qiita</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS下的输入框点击放大问题&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="Input" scheme="https://kisky3.github.io/tags/Input/"/>
    
      <category term="iOS" scheme="https://kisky3.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Install ipa file To Your iPhone</title>
    <link href="https://kisky3.github.io/2021/06/06/InstallipaFileToYouriPhone/"/>
    <id>https://kisky3.github.io/2021/06/06/InstallipaFileToYouriPhone/</id>
    <published>2021-06-06T11:16:14.000Z</published>
    <updated>2021-09-18T15:02:07.453Z</updated>
    
    <content type="html"><![CDATA[<p>如何将ipa文件安装到你的iPhone上</p><a id="more"></a><p>今天拿到了一份ipa文件，然后需要在自己的手机上进行测试。<br>记录一下测试方法。</p><p>使用的app是<code>Apple Configurator 2</code>。</p><h3 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h3><ul><li>Mac</li><li>iPhone</li><li>数据线(连接用)</li></ul><hr><h3 id="开始干"><a href="#开始干" class="headerlink" title="开始干"></a>开始干</h3><p>1.首先从App Store里下载Apple Configurator。<br>利用下面的链接, 在App Store里搜索Apple Configurator。</p><p><a href="https://apps.apple.com/jp/app/apple-configurator-2/id1037126344" target="_blank" rel="noopener">https://apps.apple.com/jp/app/apple-configurator-2/id1037126344</a></p><img src="./1.png" style="width:500px"><p>安装完之后,应该能看到下面的界面。<br><img src="./2.png" style="width:500px"></p><p>然后将iPhone和Mac进行连接。<br><img src="./3.png" style="width:500px"></p><p>点击出现的媒体图标(就是你的iPhone),然后把ipa文件拖拽进去。<br>然后就等着下载好就行了。<br><img src="./4.png" style="width:500px"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何将ipa文件安装到你的iPhone上&lt;/p&gt;
    
    </summary>
    
      <category term="System Setting" scheme="https://kisky3.github.io/categories/System-Setting/"/>
    
    
      <category term="ipa" scheme="https://kisky3.github.io/tags/ipa/"/>
    
      <category term="AppleConfigurator2" scheme="https://kisky3.github.io/tags/AppleConfigurator2/"/>
    
  </entry>
  
  <entry>
    <title>AWS CLF Lesson4〜6 Memo</title>
    <link href="https://kisky3.github.io/2021/06/05/lesson2/"/>
    <id>https://kisky3.github.io/2021/06/05/lesson2/</id>
    <published>2021-06-05T13:06:40.000Z</published>
    <updated>2021-09-18T15:02:08.474Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 云从业者基础知识 学习笔记4 〜 6</p><a id="more"></a><h3 id="4-AWSのテクノロジー"><a href="#4-AWSのテクノロジー" class="headerlink" title="4. AWSのテクノロジー"></a>4. AWSのテクノロジー</h3><h4 id="4-1-AWSのサービス"><a href="#4-1-AWSのサービス" class="headerlink" title="4.1 AWSのサービス"></a>4.1 AWSのサービス</h4><p>AWSではリージョンと呼ばれる、世界のどこでサービスを使うかを選択するための地域と、リージョンと呼ばれる、世界のどこでサービスを使うかを選択するための地域と、リージョンにあるアベイラビリティゾーンという、データセンターの集合体があります。</p><h4 id="4-2-グローバルインフラストラクチャ"><a href="#4-2-グローバルインフラストラクチャ" class="headerlink" title="4.2 グローバルインフラストラクチャ"></a>4.2 グローバルインフラストラクチャ</h4><p>全世界に展開されているリージョンを選択して、数分で世界中にシステムをデプロイできる。<br>リージョンによって利用できるサービス、コストが異なる。</p><p>リージョンにはアベイラビリティゾーンが2つ以上ある(ローカルリージョンを除く)<br>アベイラビリティゾーンは障害が同時に影響しないよう、地理的に十分に離れた場所にある。<br>同一リージョン内のアベイラビリティゾーン同士は高速なプライベート光ファイバーネットワーキングで接続されている。<br>複数のアベイラビリティゾーンを使うことで、耐障害性、可用性の高いアーキテクチャを実装できる。<br>データセンターは、セキュリティ、コンプライアンス上の様々な第三者監査検証を実施している。</p><p>リージョンとは違う場所に200以上のエッジロケーションがある。<br>エッジロケーションではAmazon Route 53とAmazon CloudFrontを利用できる。<br>ユーザーは最も低レイテンシーのエッジロケーションにアクセスできる。</p><p>Amazon Route53とAmazon CloudFrontはAWS SheildによりDDos攻撃から保護される。</p><h3 id="5-コンピューティングサービス"><a href="#5-コンピューティングサービス" class="headerlink" title="5.コンピューティングサービス"></a>5.コンピューティングサービス</h3><h4 id="5-1-EC2-Elastic-Compute-Cloud"><a href="#5-1-EC2-Elastic-Compute-Cloud" class="headerlink" title="5.1 EC2(Elastic Compute Cloud)"></a>5.1 EC2(Elastic Compute Cloud)</h4><p>使うときにだけEC2インスタンスを起動することができる。<br>必要なEC2インスタンスの数を事前に予測する必要はない。</p><p>使った文にだけ料金が発生する。<br>時間単位、秒単位で課金される。<br>アウト通信に転送料金が発生する。</p><p>インスタンスタイプは運用を開始した後に柔軟ぬ性能を変更できる。<br>運用を開始する前の、誤った性能予測の計算をする必要がなくなる。</p><p>数分でEC2を起動できることは、経営の俊敏性が増やすことに直結する。</p><p>数分でEC2を世界中にデプロイできる。</p><p>AMIから同じ構成のEC2インスタンスを何台でも起動できる。<br>AWS Marketplaceから簡単にソフトウェア構成済みのEC2インスタンスを起動できる。</p><p>EC2へのインスタンスのトラフィックはセキュリティグループのインパウンド(受信)で制御する。</p><p>オペレーティングシステムの管理者はキーペアで安全にログインできる。</p><p>数クリック、数分でEC2インスタンスを起動できる。</p><h4 id="5-2-ELB"><a href="#5-2-ELB" class="headerlink" title="5.2 ELB"></a>5.2 ELB</h4><p>EC2インスタンスの可用性を高めるためにELBを使用することができる。<br>HTTP \HTTPSではApplication Load Balancerを使い、それ以外のTCPではNetwork Load Balancerを使う。</p><p>ELBには、正常なインスタンスのみにトラフィックを送るためのヘルスチェック機能がある。</p><p>ELBはインターネット向けにも内部向けにも対応している。</p><p>インターネット向けだけではなく内部にもELBを挟むことによって、システムの可用性をさらに高めることができる。</p><p>ELB自体が高可用性のマネージドサービスなので単一障害点とはならない。</p><p>複数のアベイラビリティゾーンに負荷分散を実行できるのでリリースの負荷が均等になる。</p><p>Auto ScalingによってEC2インスタンスを必要なときに自動で増減できる。</p><p>Auto Scalingのメリットは、高可用性、耐障害性、コスト効率化。</p><p>垂直スケーリングよりも水平スケーリングの方がスケーラビリティを確保しやすい。</p><p>Auto Scalingでは起動設定(何を)、Auto Scalingグループ、スケーリングポリシーを設定する。</p><p>EC2のユーザーデーターを使うことでコマンドを自動実行し、デプロイ処理を自動化することができる。</p><p>EC2の情報(IPアドレスやインスタンスID)はタメデータから取得できる。</p><p>ELB、CloudWatch、Auto Scalingの3つのサービスで、自動敵でスケーラブルなアプリケーションを構築できる。</p><h4 id="5-4-Lambda"><a href="#5-4-Lambda" class="headerlink" title="5.4 Lambda"></a>5.4 Lambda</h4><p>サーバー構築や環境の準備をするをことなく、すぐに開発を始められる。</p><p>サーバーの運用から解放され、開発に注力できる。</p><p>Lmabdaを使うために新しい言語の勉強は不要。使い慣れた言語ですぐに始められる。</p><p>リクエストに応じて水平的にスケーリングして、並行で関数が実行される。</p><p>Auto Scalingを設定する必要がない。</p><p>メモリを割り当てることで他のリソースの性能も割り当てられる。</p><p>実行されている時間に対してミリ秒単位の無駄のない課金がなされる。</p><p>実行されていない待機時間には課金されない。</p><p>AWSサービスの処理を簡単に自動化できる。</p><p>AWSサービスからのトリガーを使用することで、イベントからLambdaを実行できる。</p><h3 id="6-ストレージサービス"><a href="#6-ストレージサービス" class="headerlink" title="6.　ストレージサービス"></a>6.　ストレージサービス</h3><h4 id="EBS-Amazon-Amazon-Elastic-Block-Store"><a href="#EBS-Amazon-Amazon-Elastic-Block-Store" class="headerlink" title="EBS (Amazon Amazon Elastic Block Store)"></a>EBS (Amazon Amazon Elastic Block Store)</h4><p>EBSはAmazon Amazon Elastic Block Storeの略です、EC2インスタンスにアタッチして使用するブロックストレージボリュームです。<br>必要な時に必要な量を利用できる。<br>使い始めた後にオンラインでボリュームタイプを変更できる。<br>使い始めた後にオンラインでストレージ容量を増やすことができる。</p><p>スナップショットはS3の機能を使って保存される。(高い耐久性)。</p><p>EBSの暗号化に対して追加の操作は必要ない。</p><p>EBSのデータは永続的、インスタンスストアは一時的。</p><h4 id="S3-Amazon-Simple-Storage"><a href="#S3-Amazon-Simple-Storage" class="headerlink" title="S3(Amazon Simple Storage)"></a>S3(Amazon Simple Storage)</h4><p>Amazon Simple Storage Serviceの略です。<br>S3のオブジェクト容量は無制限。<br>ストレージ容量の確保/調達を気にすることなく開発に専念できる。</p><p>S3の耐久性はイレブンナイン(99.9999999%)。</p><p>冗長化やバックアップを意識することなく開発に専念できる。<br>S3は世界中のどこからでもアクセスできる。</p><p>S3バケット、オブジェクトはデフォルトでプライベート。<br>アクセスコントロールリストで簡単にアクセス権を設定できる。<br>バケットポリシーでより詳細にアクセス権を設定できる。<br>EC2などのAWSリソースにS3へのアクセス権を設定する際はIAMロールを使用する。<br>HTTPSでアクセスできる。<br>保存データの暗号化は複数の方法から選択できる。</p><p>ストレージ料金はストレージクラスによりコスト効率を高めることができる。<br>ライフサイクルポリシーによりストレージクラスの変更を自動化できる。<br>リージョンの外へのアウト通信のみデータ転送料金が発生する。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS 云从业者基础知识 学习笔记4 〜 6&lt;/p&gt;
    
    </summary>
    
    
      <category term="aws" scheme="https://kisky3.github.io/tags/aws/"/>
    
      <category term="AWS Certified Cloud Practitioner" scheme="https://kisky3.github.io/tags/AWS-Certified-Cloud-Practitioner/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s the Node.js and Why Everybody use it?</title>
    <link href="https://kisky3.github.io/2021/04/22/whynodejs/"/>
    <id>https://kisky3.github.io/2021/04/22/whynodejs/</id>
    <published>2021-04-22T13:54:05.000Z</published>
    <updated>2021-09-18T15:02:08.501Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Node.js,为何人人都在用它？</p><a id="more"></a><p>说到JavaScript的学习,大家都是以Node.js存在的前提进行的,<br>今天来说说这货到底是啥,它有啥用,为何人人都在用它呢.</p><h3 id="基础-JavaScript的特征"><a href="#基础-JavaScript的特征" class="headerlink" title="基础: JavaScript的特征"></a>基础: JavaScript的特征</h3><p>首先,JavaScript和别的语言有什么区别呢？<br>JavaScript是在<code>浏览器(比如Chrome、Firefox)上</code>运行的一个编程语言。<br>但是其他的语言比如Python、Ruby之类的一般的编程语言都是在<code>计算机上</code>运行的。</p><img src="./1.png" style="width: 500px"><p>这里就涉及到了能否直接连接使用OS的功能。<br>OS的基本功能, 比如说文件的读取动能、网络通信的功能等等。<br>能在计算机上直接运行的application(Python、Ruby)等是能够直接操作这些功能的。</p><p>但是在浏览器上运行的JavaScript是不能直接操作OS的功能的。比如说你打开网页的时候如果能直接通过浏览器对你的本地计算机文件进行操作，比如文件篡改删除等等,将会造成大问题的是不。</p><p>所以,浏览器上运行的JavaScript是不允许直接操作OS功能的。<br>但是如果完全禁止JavaScript使用OS功能的话还是有一些不方便,所以有时需要通过一些<code>中介</code>来操作一部分限定的OS功能。</p><p>最近的话比如摄像头和麦克风的操作权限可以通过<code>中介</code>获取,这样我们就可以在网络会议的时候使用了！</p><img src="./2.png" style="width: 500px"><h3 id="Node-js是啥？"><a href="#Node-js是啥？" class="headerlink" title="Node.js是啥？"></a>Node.js是啥？</h3><p>上面说的这种只能在特定环境(浏览器)上运行的JavaScript也能像其他的Pythin语言一样能在OS上运行的东西就是Node.js。</p><img src="./3.png" style="width: 500px"><p>容易被误会的是Node.js不是服务器,也不是像Rails、Django这样的Web框架。<br>它是<code>JavaScript的运行环境</code>。</p><p>在Windows安装Python的话会生成一个「python.exe」、而安装Node.js的时候也会生成一个「node.exe」</p><p>python.exe是操作系统中的一个运行Python代码的可执行文件(程序),<br>同理,<code>node.exe也就是操作系统中的一个运行JavaScript代码的可执行文件(程序)</code>,</p><p>Node.js能够允许JavsScript操作OS功能。比如说之前在浏览器上不能操作文件之类的现在通过Node.js变得可能了。<br>它其实原来只是旨在构造一个能够处理大量同时连接处理的网络程序而已,经常可以听到「可以利用JavaScript来写一个服务器(而不是客户端网络)了」,使得人们有一个普遍的印象就是Node.js上服务器上的JavaScript的运行环境,是不是这个介绍其实更广为人知呢。</p><p>但是现在Node.js用在客户端网页的机会也增多了。<br>比如使用Babel,webpack之类来构建在「浏览器上运行的JavaScript」的开发环境的时候,就经常要用到Node.js.</p><p>可以说Node.js是在服务器端和客户端两边的JavaScript的运行环境。</p><hr><h3 id="npm是何方神圣？"><a href="#npm是何方神圣？" class="headerlink" title="npm是何方神圣？"></a>npm是何方神圣？</h3><p>在这里也顺便说一下什么是npm.</p><p>npm是Node.js的版本管理工具.<br>就像pip之于Python,gem之于Ruby,apt之于Debian,Homebrew之于Mac,cargo之于Rust.</p><p>yarn有时也会出来,可以看作是和npm差不多的东西.</p><p>而通过npm/yarn安装的package可以看作是库和框架之类的东西.<br>比如Vue,React,webpack,jQuery之类的东西.</p><p>在Node.js下如果有你想使用的库,就不用像以前一样下载js,并写入引用的代码<code>&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</code>了.<br>直接使用npm安装就好！</p><hr><h3 id="为何人人都在用Node-js呢"><a href="#为何人人都在用Node-js呢" class="headerlink" title="为何人人都在用Node.js呢"></a>为何人人都在用Node.js呢</h3><p>使用Node.js的话能解开JavaScript的很多枷锁.<br>目前使用Node.js的人目的大概分为以下三类.</p><p>1.想使用新式的JavaScript或者TypeScript来编写客户端.<br>2.想用JavaScript来写一个web应用程序.<br>3.想写一个手机端/电脑端的程序.</p><p>下面来详细说一下:</p><h5 id="1-想使用新式的JavaScript或者TypeScript来编写客户端"><a href="#1-想使用新式的JavaScript或者TypeScript来编写客户端" class="headerlink" title="1.想使用新式的JavaScript或者TypeScript来编写客户端"></a>1.想使用新式的JavaScript或者TypeScript来编写客户端</h5><p>JavaScript基本每年都在更新,特别是ES2015之后更是加了很多便利的新功能.<br>但是JavaScript更新了,而浏览器却还是老样子并没有跟上JavaScript的脚步,导致了一些功能性的问题.</p><p>为了解决这个问题只能将「新样式的JavaScript文件」机械化地转换成「老版的(ES5)的javaScript文件」,从而让浏览器能够顺利地识别.</p><p>这样的转换工具(转换编译器)主流的就是<code>Babel</code>,而为了运行这个编译工具需要特定的运行环境,而Node.js通常作为配套使用.</p><hr><h5 id="2-想用JavaScript来写一个web应用程序"><a href="#2-想用JavaScript来写一个web应用程序" class="headerlink" title="2.想用JavaScript来写一个web应用程序."></a>2.想用JavaScript来写一个web应用程序.</h5><p>就像Ruby+Rails,Python+Django来写一个程序一样,Node.js也能帮你实现。</p><table><thead><tr><th>実行環境</th><th>言語</th><th>Webフレームワーク</th></tr></thead><tbody><tr><td>Ruby</td><td>Ruby</td><td>Ruby on Railsなど</td></tr><tr><td>Python</td><td>Python</td><td>Djangoなど</td></tr><tr><td>Node.js</td><td>JavaScript</td><td>Expressなど</td></tr></tbody></table><p>通常像<code>Apache</code>和<code>nginx</code>一样使用<code>Node.js</code>作为服务器代理可以直接接收HTTP的request并进行处理.<br>但实际上Node.js作为网络服务器的话还是有一点功能不齐全,有时会在它之间使用Apache或者nginx来进行反向代理.</p><h6 id="关于正向代理和反向代理"><a href="#关于正向代理和反向代理" class="headerlink" title="关于正向代理和反向代理"></a>关于正向代理和反向代理</h6><p>正向代理隐藏了真实的请求客户端,服务端不知道真实的客户端是谁,客户端的请求都被代理服务器代替来请求.</p><p>而反向代理隐藏了真实的服务端,反向代理服务器会帮助我们把用户端的请求转发到真实的服务器那里去.nginx就是性能非常好的反向代理服务器,常用于复杂均衡.</p><p>也就是说正向代理代理的对象是客户端，反向代理代理的对象是服务端.</p><h5 id="3-想写一个手机端-电脑端的程序"><a href="#3-想写一个手机端-电脑端的程序" class="headerlink" title="3.想写一个手机端/电脑端的程序"></a>3.想写一个手机端/电脑端的程序</h5><p>Node.js也可用于手机端或者电脑端的开发.</p><p>手机端的框架的话常见的有React Native,电脑端的有Electron.</p><h5 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h5><p>其他的还有,将网页的部件进行打包(webpack)的时候，Node.js就能发挥作用了,比如Sass转换成CSS(node-sass)的时候就用到Node.js,测试工具(Jtest),代码检测工具(ESLint)的时候也需要Node.js,还有想搭建一个简易的本地服务器(webpack-dev-server)的时候也用到Node.js,还有搭建静态页面(Gatsby)的时候也需要使用Node.js.</p><p>可以看到Node.js有很多实用的功能呢.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是Node.js,为何人人都在用它？&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="node.js" scheme="https://kisky3.github.io/tags/node-js/"/>
    
      <category term="npm" scheme="https://kisky3.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Set localStorage Wih JS , Read With CakePHP</title>
    <link href="https://kisky3.github.io/2021/04/19/SetCookieWihJS-ReadWithCakePHP/"/>
    <id>https://kisky3.github.io/2021/04/19/SetCookieWihJS-ReadWithCakePHP/</id>
    <published>2021-04-19T14:55:01.000Z</published>
    <updated>2021-09-18T15:02:08.171Z</updated>
    
    <content type="html"><![CDATA[<p>在js里设定localStorage,并在CakePHP里使用</p><a id="more"></a><p>在最近要在js里设定localStorage,并在CakePHP里读取js的localStorage.而且使用js和CakePHP的地方分别处于两个repo.</p><p>为了解决这个问题,费了一点时间.<br>下面不知道是不是最好的方法,但是能够满足需求了.</p><ol><li>在Javascript里设定localStorage</li></ol><!-- javascript --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'mytext'</span>, <span class="string">'Hello, World!'</span>);</span><br></pre></td></tr></table></figure><p>如果对期限有要求的话可以考虑使用sessionStorage, 或者自己将时间的数据存到storage里, 并在读取localstorage时获取现在时刻进行对比并追加处理.</p><ol start="2"><li>在CakePHP里创建Element,并在template里通过js引用.<br>例子：</li></ol><p>my-project/myname/Template/Element/helloworld.tpl</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> test = localStorage.getItem(<span class="string">"mytext"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>CakePHP template</p><p>test.tpl</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;$<span class="keyword">this</span>-&gt;Element(<span class="string">'helloworld'</span>)&#125;</span><br><span class="line"><span class="comment">// other CakePHP coding...</span></span><br></pre></td></tr></table></figure><p>这样在加载test.tpl的时候就能够通过element读取之前保存在本地的localstorage了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js里设定localStorage,并在CakePHP里使用&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="CakePHP" scheme="https://kisky3.github.io/tags/CakePHP/"/>
    
      <category term="Cookie" scheme="https://kisky3.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>New Feature - Vue 3&#39;s Full TypeScript Support</title>
    <link href="https://kisky3.github.io/2021/04/09/NewFeaturesinVue3/"/>
    <id>https://kisky3.github.io/2021/04/09/NewFeaturesinVue3/</id>
    <published>2021-04-09T14:58:23.000Z</published>
    <updated>2021-09-18T15:02:08.089Z</updated>
    
    <content type="html"><![CDATA[<p>Vue3的新特性以及对TypeScript的全支持</p><a id="more"></a><p>以前使用Vue2的时候相信很多朋友都没有特别好的体验。<br>但是尤大发布Vue3之后，据说能够友好地拥抱TypeScript了。<br>今天一边谈谈Vue3大新特性一边总结一下在Vue3里使用TypeScript的方法。</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><p>这是Vue3追加的最受注目的功能。Props和Content就可以生成全体Component都能使用和参照的参数。有点像React Hooks里记述的可以动态参照的参数。</p><p>原本的Vue2的Component里的话一般都像下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      repositories: [],</span><br><span class="line">      filters: &#123; ... &#125;,</span><br><span class="line">      searchQuery: ''</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;,</span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    user: 'getUserRepositories'</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getUserRepositories () &#123;</span><br><span class="line">      // using `this.user` to fetch user repositories</span><br><span class="line">    &#125;,</span><br><span class="line">    updateFilters () &#123; ... &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getUserRepositories()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会导致Component变得沉重,本来只是想进行一个处理, 但是却分散在不同的地方，影响可读性。<br>像下面这样同样的处理全部总结写在一处比较好。</p><p>例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import &#123; fetchUserRepositories &#125; from '@/api/repositories'</span><br><span class="line">import &#123; ref, onMounted, watch, toRefs, computed &#125; from 'vue'</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    // using `toRefs` to create a Reactive Reference to the `user` property of props</span><br><span class="line">    const &#123; user &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">    const repositories = ref([])</span><br><span class="line">    const getUserRepositories = async () =&gt; &#123;</span><br><span class="line">      // update `props.user` to `user.value` to access the Reference value</span><br><span class="line">      repositories.value = await fetchUserRepositories(user.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onMounted(getUserRepositories)</span><br><span class="line"></span><br><span class="line">    // set a watcher on the Reactive Reference to user prop</span><br><span class="line">    watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">    const searchQuery = ref('')</span><br><span class="line">    const repositoriesMatchingSearchQuery = computed(() =&gt; &#123;</span><br><span class="line">      return repositories.value.filter(</span><br><span class="line">        repository =&gt; repository.name.includes(searchQuery.value)</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      repositories,</span><br><span class="line">      getUserRepositories,</span><br><span class="line">      searchQuery,</span><br><span class="line">      repositoriesMatchingSearchQuery</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>setup</code>返回的值可以供全体Component使用。</li><li><code>toRefs</code>和<code>ref</code>能够参照动态值,Component里使用<code>hoge.value</code>可以动态参照修改后的值。</li><li>支持生命周期,<code>onMounted</code>里可以指定在mount之后实行的参数。</li><li>使用<code>computed</code>后也可以生成computed value。</li></ul><hr><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Vue Component里的dom的一部分, 在渲染的时候可以在指定的dom下进行描画。<br>在body下描画全画面的model的时候可以使用。</p><p>例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.component('modal-button', &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"modalOpen = true"</span>&gt;</span></span><br><span class="line">        Open full screen modal! (With teleport!)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"modalOpen"</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">          I'm a teleported modal!</span><br><span class="line">          (My parent is "body")</span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"modalOpen = false"</span>&gt;</span></span><br><span class="line">            Close</span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line">  `,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      modalOpen: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><p>在route里放置多个dom.</p><p>例: (v2)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例: (v3)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Emits-Component-Option"><a href="#Emits-Component-Option" class="headerlink" title="Emits Component Option"></a>Emits Component Option</h3><p>新追加的option.<br>为了记录Component是怎样运行的, 推荐写在所有emit了的自定义方法里面.</p><p>例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">app.component('custom-form', &#123;</span><br><span class="line">  emits: &#123;</span><br><span class="line">    // No validation</span><br><span class="line">    click: null,</span><br><span class="line"></span><br><span class="line">    // Validate submit event</span><br><span class="line">    submit: (&#123; email, password &#125;) =&gt; &#123;</span><br><span class="line">      if (email &amp;&amp; password) &#123;</span><br><span class="line">        return true</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.warn('Invalid submit event payload!')</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm() &#123;</span><br><span class="line">      this.$emit('submit', &#123; email, password &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>也可以使用<code>emit: [&quot;click&quot;, &quot;submit&quot;]</code>这样的数列来进行定义.</li><li>如果使用object来指定参数的话, 将会被作为Validator来运行.</li></ul><hr><h3 id="Custom-Render-createRender"><a href="#Custom-Render-createRender" class="headerlink" title="Custom Render(createRender)"></a>Custom Render(createRender)</h3><p>可以自定义你的渲染器。<br>可以使用option来在渲染的时候插入特定的处理.</p><p>例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createRenderer &#125; from '@vue/runtime-core'</span><br><span class="line">import &#123; nodeOps &#125; from '@vue/runtime-dom'</span><br><span class="line"></span><br><span class="line">const &#123; render, createApp &#125; = createRenderer(&#123;</span><br><span class="line">  ...nodeOps,</span><br><span class="line">  insert: () =&gt; &#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// `render` is the low-level API</span><br><span class="line">// `createApp` returns an app instance with configurable context shared</span><br><span class="line">// by the entire app tree.</span><br><span class="line">export &#123; render, createApp &#125;</span><br><span class="line"></span><br><span class="line">export * from '@vue/runtime-core'</span><br></pre></td></tr></table></figure><hr><h3 id="TypeScript应对"><a href="#TypeScript应对" class="headerlink" title="TypeScript应对"></a>TypeScript应对</h3><p>下面是重头戏TS的应对.</p><p>定义Component的时候请注意<br>1.<code>script</code>标签里进行ts的声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用<code>defineComponent</code>参数<br>为了在Component里使用正确的类型定义,这里不使用常用的class,使用以下的参数就必须新生成一个Component.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent &#125; from 'vue'</span><br><span class="line"></span><br><span class="line">const Component = defineComponent(&#123;</span><br><span class="line">  // type inference enabled</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改变的点：<br>Vue3开始对TS进行全力的支持这一点相信大家都有听过,Vue3里对TS部分进行了全部的重新定义,只是Composition API里对逻辑进行了总结, TS因此变得更好用了?</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue3的新特性以及对TypeScript的全支持&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="Vue3" scheme="https://kisky3.github.io/tags/Vue3/"/>
    
      <category term="Typescript" scheme="https://kisky3.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>AWS Amplify Memo</title>
    <link href="https://kisky3.github.io/2021/03/24/AmplifyError/"/>
    <id>https://kisky3.github.io/2021/03/24/AmplifyError/</id>
    <published>2021-03-24T14:44:34.000Z</published>
    <updated>2021-09-18T15:02:06.916Z</updated>
    
    <content type="html"><![CDATA[<p>AWS Amplify常见的坑</p><a id="more"></a><p>最近用Amplify踩了一些坑。在这里总结一下错误。</p><h3 id="1-GraphQLError-Request-failed-with-status-code-401"><a href="#1-GraphQLError-Request-failed-with-status-code-401" class="headerlink" title="1. GraphQLError: Request failed with status code 401"></a>1. GraphQLError: Request failed with status code 401</h3><p>Graphql的API返回401的时候很可能是你设置的API Key过期了。<br>你最初通过命令行默认设置的API的API Key期限是七天。</p><p>AWS AppSync -&gt; 設定 -&gt; 在默认认证模式下添加API Key,然后在aws-exports.js 里更行aws_appsync_apiKey的値。</p><p>最长可以设置一年的期限。<br>其实最好的是设置一个可用的IAM用户,但是我还没有摸索出来。(汗)</p><hr><h3 id="2-amplify-codegen"><a href="#2-amplify-codegen" class="headerlink" title="2. amplify codegen"></a>2. amplify codegen</h3><p>这个命令用于你修改了schema之后更新<code>/arc/graphql/</code>目录下的GraphQL。<br>Graphql文件夹里面的内容会根据schema进行自动的typr配型和生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">amplify add codegen --apiId &#123;appsync_graphql_id&#125;</span><br><span class="line">amplify codegen</span><br></pre></td></tr></table></figure><hr><h3 id="3-Validation-error-of-type-FieldUndefined"><a href="#3-Validation-error-of-type-FieldUndefined" class="headerlink" title="3. Validation error of type FieldUndefined"></a>3. Validation error of type FieldUndefined</h3><p>这个情况是出现在先通过scheme生成了src/graphql的query之类的API之后,运行<code>amplify codegen</code>进行更行graphql而可能出现的错误。</p><p>这是因为你的AppSync API需要使用DataStore category。<br>所以解决步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">amplify update api</span><br><span class="line">// 选择GraphQL</span><br><span class="line">// 选择Enable DataStore for entire API</span><br><span class="line">amplify push</span><br></pre></td></tr></table></figure><p>参考:<br><a href="https://github.com/aws-amplify/amplify-cli/issues/5339" target="_blank" rel="noopener">https://github.com/aws-amplify/amplify-cli/issues/5339</a></p><blockquote><p>Here’s the important part of the error: Field ‘syncTodos’ in type ‘Query’ is undefined.</p></blockquote><blockquote><p>I believe this is because you don’t have conflict detection on your AppSync API, which needs to be enabled to using the DataStore category. It should be disabled if you are using the API category. To enable it, run amplify update api, choose “GraphQL”, then choose “Enable DataStore for entire API”, then run amplify push</p></blockquote><blockquote><p>I’m leaving this issue open as an improvement opportunity, so that we can look at making the error message more helpful, as this issue has been raised several times now.</p></blockquote><hr><h4 id="4-什么是AppSync"><a href="#4-什么是AppSync" class="headerlink" title="4. 什么是AppSync"></a>4. 什么是AppSync</h4><p>AppSync就是AWS提供的一个能够灵活地使用GraphQL API的一个管理类服务。<br>也就是相当于是用AWS API Gateway来提供一个常见的REST API。</p><p>AppSync可以直接修改DynamoDB的值,并进行获取/更新/删除等常见操作。<br>而一般来说API Gateway一般中间要搭配和Lambda进行使用。但是AppSync的话就可以不使用Lambda来进行DynamoDB的直接连接。</p><p>Graphql的query类型一般有3种。query:read, mutation:create / update / delete, subscription: get date realtime</p><h4 id="5-amplify-pull-–appId-xxxxxxx-–envName-dev"><a href="#5-amplify-pull-–appId-xxxxxxx-–envName-dev" class="headerlink" title="5. amplify pull –appId xxxxxxx –envName dev"></a>5. amplify pull –appId xxxxxxx –envName dev</h4><p>这个命令行用于在deploy之后，别的测试环境里可以取得同样的后端代码。<br>前端部署的话首先从Github里clone代码,然后使用这个命令,并进行问答式对话来获取相同AWS region Amplify 的后端部署。(连接数据库之类的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amplify pull --appId xxxxxxx --envName dev</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS Amplify常见的坑&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="AWS" scheme="https://kisky3.github.io/tags/AWS/"/>
    
      <category term="Ampliy" scheme="https://kisky3.github.io/tags/Ampliy/"/>
    
  </entry>
  
  <entry>
    <title>About AWS SQS and SNS</title>
    <link href="https://kisky3.github.io/2021/03/11/AboutAWSSQSandSNS/"/>
    <id>https://kisky3.github.io/2021/03/11/AboutAWSSQSandSNS/</id>
    <published>2021-03-10T15:50:23.000Z</published>
    <updated>2021-09-18T15:02:06.875Z</updated>
    
    <content type="html"><![CDATA[<p>AWS的SQS和SNS详解</p><a id="more"></a><h2 id="SQS-Simple-Queue-Service"><a href="#SQS-Simple-Queue-Service" class="headerlink" title="SQS (Simple Queue Service)"></a>SQS (Simple Queue Service)</h2><p><code>Amazon Simple Queue Service (SQS)是一种完全托管的消息队列服务</code>，可以让你分离和扩展微服务、分布式系统和无服务应用程序。</p><p>在讲解SQS之前，首先让我们了解一下什么是消息队列。</p><h4 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h4><p>消息队列<br>还是举一个电商的例子，一个用户在电商网站下单后付款后，应用服务器马上查询/更新数据库，连接支付网关并查询支付状态，通知短信/邮件网关发送相关短信/邮件，更新库存系统，更新物流系统……最后返回信息给用户，“您的下单已成功”。</p><p>但是如果网站的访问数很大，或者正值促销活动（比如淘宝双11，京东618）呢？</p><p>这个时候每一个流程都是一个瓶颈，一旦某一个地方达到了瓶颈或者出现故障，又或者用户下单的时间比程序处理订单的时间还要久的情况下，都会让用户得不到成功下单的结果，或者得到结果的时间非常长，导致用户体验不好。</p><p>这个时候，我们就要考虑到应用程序的解耦（decouple）。</p><p>我们可以引入消息队列，让不同的应用程序之间打断强连接的关系，互不干扰。</p><p>应用服务器在接收到用户付款的订单之后，就把相关的信息丢到消息队列，并且返回用户“您的下单已成功，请稍后查看详细订单状态”。</p><p>而支付网关、短信/邮件网关、库存系统、物流系统等等可以到消息队列里面拉取信息，并且进行相关的数据更新和操作。</p><p>这些操作可能不需要是实时的，但是至少能保证这些队列里的信息最终都会被执行。比如下单后我不一定马上能收到短信/邮件的通知，我可能5分钟/10分钟之后才收到这些信息通知，但这个并不影响正常的业务。</p><p>这样子，<code>消息队列就起到了连接上层业务和下层业务的作用</code>。</p><p><code>Amazon SQS相当于提供了一个分布式、高可用、高性能的消息队列服务</code>。</p><h4 id="SQS特点"><a href="#SQS特点" class="headerlink" title="SQS特点"></a>SQS特点</h4><p>SQS有两种不同类型的队列，它们分别是：</p><ul><li>标准队列（Standard Queue）</li><li>FIFO队列（先进先出队列）</li></ul><h5 id="标准队列"><a href="#标准队列" class="headerlink" title="标准队列"></a>标准队列</h5><p>标准队列拥有无限的吞吐量，所有消息都会至少传递一次，并且它会尽最大努力进行排序。</p><p>标准队列是默认的队列类型。</p><img src="./1.png" style="width: 300px"><h5 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h5><p>FIFO (First-in-first-out)队列在不使用批处理的情况下，最多支持300TPS（每秒300个发送、接受或删除操作）。</p><p>在队列中的消息都只会不多不少地被处理一次。</p><p>FIFO队列严格保持消息的发送和接收顺序。</p><img src="./2.png" style="width: 300px"><h3 id="SQS的其他特点"><a href="#SQS的其他特点" class="headerlink" title="SQS的其他特点"></a>SQS的其他特点</h3><ul><li>SQS是靠应用程序去拉取的，而不能主动推送给应用程序，推送服务我们使用SNS（Simple - Notification Service）</li><li>消息会以256 KB的大小存放</li><li>消息会在队列中保存1分钟~14天，默认时间是4天</li><li>可见性超时（Visibility Timeout）<ul><li>即当SQS队列收到新的消息并且被拉取走进行处理时，会触发Visibility Timeout的时间。这个消息不会被删除，而是会被设置为不可见，用来防止该消息在处理的过程中再一次被拉取</li><li>当这个消息被处理完成后，这个消息会在SQS中被删除，表示这个任务已经处理完毕</li><li>如果这个消息在Visibility Timeout时间结束之后还没有被处理完，则这个消息会设置为可见状态，等待另一个程序来进行处理,因此同一个消息可能会被处理两次（或以上）</li><li>这个超时时间最大可以设置为12小时</li></ul></li><li>标准SQS队列保证了每一个在队列内的消息都至少会被处理一次</li><li>长轮询（Long Polling）<ul><li>默认情况下，Amazon SQS使用短轮询（Short Polling），即应用程序每次去查询SQS队列，SQS都会做回应（哪怕队列一直是空的）</li><li>使用了长轮训，应用程序每次去查询SQS队列，SQS队列不会马上做回应。而是等到队列里有消息可处理时，或者等到设定的超时时间再做出回应。</li><li>长轮询可以一定程度减少SQS的花销</li></ul></li></ul><hr><h3 id="SNS-Simple-Notification-Service"><a href="#SNS-Simple-Notification-Service" class="headerlink" title="SNS (Simple Notification Service)"></a>SNS (Simple Notification Service)</h3><p><code>SNS (Simple Notification Service) 是一种完全托管的发布/订阅消息收发和移动通知服务，用于协调向订阅终端节点和客户端的消息分发</code>。</p><p>和SQS (Simple Queue Service)一样，SNS也可以轻松分离和扩展微服务，分布式系统和无服务应用程序，对程序进行解耦。</p><p>我们可以使用SNS将消息推送到SQS消息队列中、AWS Lambda函数或者HTTP终端节点上。</p><p>SNS通知还可以发送推送通知到IOS，安卓，Windows和基于百度的设备，也可以通过电子邮箱或者SMS短信的形式发送到各种不同类型的设备上。</p><img src="./3.png" style="width: 500px"><h4 id="SNS的一些特点"><a href="#SNS的一些特点" class="headerlink" title="SNS的一些特点"></a>SNS的一些特点</h4><ul><li>SNS是实时的推送服务（Push），有别于SQS的拉取服务（Pull/Poll）</li><li>拥有简单的API，可以和其他应用程序兼容</li><li>可以通过多种不同的传输协议进行集成</li><li>便宜、用多少付费多少的服务模型</li><li>在AWS管理控制台上就可以进行简单的操作</li></ul><h4 id="SNS能推送的目标"><a href="#SNS能推送的目标" class="headerlink" title="SNS能推送的目标"></a>SNS能推送的目标</h4><ul><li>HTTP</li><li>HTTPS</li><li>Email</li><li>Email-JSON</li><li>SQS</li><li>Application</li><li>Lambda</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS的SQS和SNS详解&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="AWS" scheme="https://kisky3.github.io/tags/AWS/"/>
    
      <category term="SNS" scheme="https://kisky3.github.io/tags/SNS/"/>
    
      <category term="SQS" scheme="https://kisky3.github.io/tags/SQS/"/>
    
  </entry>
  
  <entry>
    <title>Three.js Memo</title>
    <link href="https://kisky3.github.io/2021/03/10/ThreejsMemo/"/>
    <id>https://kisky3.github.io/2021/03/10/ThreejsMemo/</id>
    <published>2021-03-10T06:22:42.000Z</published>
    <updated>2021-09-18T15:02:08.192Z</updated>
    
    <content type="html"><![CDATA[<p>Three.js学习笔记</p><a id="more"></a><h3 id="1-什么是WebGL"><a href="#1-什么是WebGL" class="headerlink" title="1. 什么是WebGL"></a>1. 什么是WebGL</h3><p>你可以把WebGL简单地认为是一种网络标准，定义了一些较底层的图形接口。在这些标准被定义之后，Chrome、Firefox之类的浏览器实现了这些标准。然后，程序员就能通过JavaScript代码，在网页上实现三维图形的渲染了。</p><h3 id="2-什么是Three-js"><a href="#2-什么是Three-js" class="headerlink" title="2. 什么是Three.js"></a>2. 什么是Three.js</h3><blockquote><p>Three.js是一个3D JavaScript库。</p></blockquote><h3 id="3-Three-js能用来干什么"><a href="#3-Three-js能用来干什么" class="headerlink" title="3. Three.js能用来干什么"></a>3. Three.js能用来干什么</h3><p>Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。我们都知道，更高的封装程度往往意味着灵活性的牺牲，但是Three.js在这方面做得很好。几乎不会有WebGL支持而Three.js实现不了的情况，而且就算真的遇到这种情况，你还是能同时使用WebGL去实现，而不会有冲突。</p><h3 id="4-WebGL-vs-Three-js"><a href="#4-WebGL-vs-Three-js" class="headerlink" title="4. WebGL vs. Three.js"></a>4. WebGL vs. Three.js</h3><p>对于一个简单的功能:渲染黑色背景下的白色正方形和三角形,使用原生WebGL接口实现同样功能需要5倍多的代码量，而且很多代码对于没有图形学基础的程序员是很难看懂的。由这个例子我们可以看出，使用Three.js开发要比WebGL更快更高效。尤其对图形学知识不熟悉的程序员而言，使用Three.js能够降低学习成本，提高三维图形程序开发的效率。</p><h3 id="5-开发环境"><a href="#5-开发环境" class="headerlink" title="5. 开发环境"></a>5. 开发环境</h3><p>Three.js是一个JavaScript库，所以，你可以使用平时开发JavaScript应用的环境开发Three.js应用。<br>推荐：Chrome<br>repo：<a href="https://github.com/mrdoob/three.js/tree/master/build" target="_blank" rel="noopener">https://github.com/mrdoob/three.js/tree/master/build</a></p><p>引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;three.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后就能通过全局变量THREE访问到所有属性和方法了。</p><h3 id="6-练习1-Hello-world"><a href="#6-练习1-Hello-world" class="headerlink" title="6. 练习1: Hello, world!"></a>6. 练习1: Hello, world!</h3><p>详细coding请参照我的GitHub repo.</p><p>首先，在HTML的<head><meta name="generator" content="Hexo 3.9.0">部分，需要声明外部文件three.js。</head></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>WebGL的渲染是需要HTML5 Canvas元素的，你可以手动在HTML的<body>部分中定义Canvas元素，或者让Three.js帮你生成。这两种选择一般没有多大差别，我们在此手动在HTML中定义：<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.9}});</script></body></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mainCanvas"</span> <span class="attr">width</span>=<span class="string">"400px"</span> <span class="attr">height</span>=<span class="string">"300px"</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在JavaScript代码中定义一个init函数，在HTML加载完后执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个典型的Three.js程序至少要包括渲染器（Renderer）、场景（Scene）、照相机（Camera），以及你在场景中创建的物体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Three.js学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="three.js" scheme="https://kisky3.github.io/tags/three-js/"/>
    
      <category term="WebGL" scheme="https://kisky3.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>AWS Memo</title>
    <link href="https://kisky3.github.io/2021/03/03/AWSMemo/"/>
    <id>https://kisky3.github.io/2021/03/03/AWSMemo/</id>
    <published>2021-03-03T14:52:49.000Z</published>
    <updated>2021-09-18T15:02:06.867Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 云从业者基础知识 学习笔记汇总</p><a id="more"></a><h4 id="セキュリティ"><a href="#セキュリティ" class="headerlink" title="セキュリティ"></a>セキュリティ</h4><h5 id="IAM-Identity-and-Access-Management"><a href="#IAM-Identity-and-Access-Management" class="headerlink" title="IAM (Identity and Access Management)"></a>IAM (Identity and Access Management)</h5><p>⇒ユーザーのAWSリソースへのアクセス管理サービス（権限設定）<br>・IAMユーザを作っての運用が推奨</p><h5 id="セキュリティグループ"><a href="#セキュリティグループ" class="headerlink" title="セキュリティグループ"></a>セキュリティグループ</h5><p>⇒インスタンスに対して設定する(トラフィックを制御する)仮想ファイアウォール<br>・オンプレ(1LANに1ファイアウォール)とは違い、各インスタンスごとに設定できる<br>・許可するインバウンドのポートと送信元を設定するホワイトリスト<br>・送信元には、CIDRか他のセキュリティグループを指定</p><p>★CIDR (Classless Inter-Domain Routing)<br>⇒IPアドレスの範囲を定義する（10.0.0.0/16など）</p><h5 id="ネットワークACL-Access-Control-List"><a href="#ネットワークACL-Access-Control-List" class="headerlink" title="ネットワークACL (Access Control List)"></a>ネットワークACL (Access Control List)</h5><p>⇒サブネットに対して設定する仮想ファイアウォール<br>・拒否するインバウンドのポートと送信元を設定するブラックリスト<br>・必要がなければ設定しない追加のセキュリティレイヤー</p><h5 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h5><p>⇒DDoS攻撃に対する保護サービス<br>・StandardプランとAdvancedプラン(AWS WAFが無償で無制限に利用可能)がある<br>・エッジロケーションで使用</p><p>★DDoS攻撃 (Distributed Denial of Service attack)<br>⇒通信量を増大させて、通信処理に負荷をかけ、サービスを利用困難・ダウンさせる攻撃</p><h5 id="AWS-WAF-Web-Application-Firewall"><a href="#AWS-WAF-Web-Application-Firewall" class="headerlink" title="AWS WAF (Web Application Firewall)"></a>AWS WAF (Web Application Firewall)</h5><p>⇒Webアプリケーションのファイアウォール<br>・可用性低下、セキュリティ侵害、リソースの過剰消費など一般的なWebの脆弱性からアプリを保護する<br>・基本量は無料だが、セキュリティルールに基づいて課金<br>・セキュリティルールの設定が必要<br>・適用先は、CloudFront/Application Load Balancer/API Gatewayから選択</p><h5 id="Inspector"><a href="#Inspector" class="headerlink" title="Inspector"></a>Inspector</h5><p>⇒EC2上のアプリのセキュリティ・コンプライアンス向上のための脆弱性診断サービス<br>・自動でアプリを診断し、問題をリスト化</p><h4 id="コンピューティング"><a href="#コンピューティング" class="headerlink" title="コンピューティング"></a>コンピューティング</h4><h5 id="EC2-Elastic-Compute-Cloud"><a href="#EC2-Elastic-Compute-Cloud" class="headerlink" title="EC2 (Elastic Compute Cloud)"></a>EC2 (Elastic Compute Cloud)</h5><p>⇒仮想コンピュータ<br>・必要なときに必要なだけ使用 → 使用した分だけ課金<br>・変更可能なインスタンスタイプから性能を選択 → 運用開始後に変更可能<br>・数分でサーバー調達して起動 → 経営の俊敏性向上<br>・世界中のリージョンから起動場所を選択 → 世界中にデプロイ<br>・AMIからいくつも同じ構成のサーバーを作成できる<br>・セキュリティグループでトラフィック制御<br>・OSを管理者権限で操作 → キーペアで安全にログインできる<br>・ユースケースに応じた料金オプションがある → コスト効率の向上</p><h5 id="ELB-Elastic-Load-Balancing"><a href="#ELB-Elastic-Load-Balancing" class="headerlink" title="ELB (Elastic Load Balancing)"></a>ELB (Elastic Load Balancing)</h5><p>→EC2インスタンスを複数のAZに配置した際に、ユーザーからのアクセスを一本化するためのもの<br>→EC2を複数AZに配置すると、障害が起きてもシステムは停止しにくい<br>→可用性、対障害性の向上のために使うサービス<br>・ロードバランサータイプは3つ → HTTP/HTTPではApplication Load Balancer<br>・ヘルスチェック → 正常なインスタンスのみにトラフィックを送るため<br>・インターネット向け/内部向け両方に対応 → 内部向けにもELBを挟むことで可溶性をさらに向上<br>・高可用性のマネージドサービス → 自動・水平にノードが増えるので、単一障害点とならない<br>・クロスゾーン負荷分散 → AZを超えて負荷分散をする設定 → リソースの負荷が均等に</p><h5 id="★AMI-Amazon-Machine-Image"><a href="#★AMI-Amazon-Machine-Image" class="headerlink" title="★AMI (Amazon Machine Image)"></a>★AMI (Amazon Machine Image)</h5><p>⇒EC2インスタンスのテンプレート（サーバ構成)</p><h5 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h5><p>⇒EC2インスタンスを必要に応じて自動増減してくれるサービス<br>→高可用性、耐障害性、コスト効率化になる<br>・垂直スケーリング → インスタンスの性能変更 → システムの設計変更が発生するため面倒<br>・水平スケーリング → インスタンスの数を変更 → スケーラビリティを確保しやすい<br>・起動設定、Auto Scalingグループ、スケーリングポリシーを設定<br>（何をスケールするか）、（どのAZでスケールするか）、（どのタイミングでスケールするか）<br>・アプリデプロイを自動化</p><h5 id="★ステートレス"><a href="#★ステートレス" class="headerlink" title="★ステートレス"></a>★ステートレス</h5><p>⇒EC2に情報やステータスを持たせない（スケールイン時に削除されてしまうので）</p><h5 id="★ブートストラップ"><a href="#★ブートストラップ" class="headerlink" title="★ブートストラップ"></a>★ブートストラップ</h5><p>⇒ユーザーデータとメタデータを使って、アプリのデプロイをより簡易化するための設計パターン<br>（ここで言うデプロイはアプリ改修の場合）</p><h5 id="★ユーザーデータ"><a href="#★ユーザーデータ" class="headerlink" title="★ユーザーデータ"></a>★ユーザーデータ</h5><p>⇒インスタンス起動時に行う処理を設定しておくもの</p><h5 id="★メタデータ"><a href="#★メタデータ" class="headerlink" title="★メタデータ"></a>★メタデータ</h5><p>⇒EC2の情報（パブリックIP、インスタンスIDなど）<br>→EC2を起動する前に、情報をメタデータから取得できる</p><h5 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h5><p>⇒ソースコードさえあればプログラムを実行できるサービス<br>→環境構築しなくていい<br>・サーバーの構築、管理不要<br>・一般的な言語のサポート → Rubyなどの言語が使えるので、新しく何かを学ぶ必要がない<br>・並行処理／スケーリング → リクエストに応じて自動で水平スケーリングし並行処理＝スケーラビリティ確保<br>・柔軟なリソースを設定 → メモリを設定する（課金対象ここ）。CPUなどはメモリに応じる<br>・ミリ秒単位の無駄のない課金 → 実行されている時間に課金<br>・他のAWSサービスとの連携 ⇒ サービス間の動作をつなぐマクロみたいな役割できる</p><h4 id="その他のコンピューティングサービス"><a href="#その他のコンピューティングサービス" class="headerlink" title="その他のコンピューティングサービス"></a>その他のコンピューティングサービス</h4><h5 id="★ECS-Elastic-Container-Service"><a href="#★ECS-Elastic-Container-Service" class="headerlink" title="★ECS (Elastic Container Service)"></a>★ECS (Elastic Container Service)</h5><p>⇒コンテナ管理を行うマネージドサービス</p><h5 id="★Lightsail"><a href="#★Lightsail" class="headerlink" title="★Lightsail"></a>★Lightsail</h5><p>⇒仮想プライベートサーバー</p><h5 id="★Batch"><a href="#★Batch" class="headerlink" title="★Batch"></a>★Batch</h5><p>⇒フルマネージド型のバッチ処理実行環境サービス</p><h4 id="ストレージ"><a href="#ストレージ" class="headerlink" title="ストレージ"></a>ストレージ</h4><h5 id="EBS-Elastic-Block-Store"><a href="#EBS-Elastic-Block-Store" class="headerlink" title="EBS (Elastic Block Store)"></a>EBS (Elastic Block Store)</h5><p>⇒EC2インスタンスにアタッチして使うブロックストレージボリューム<br>・EC2のルートボリュームor追加ボリュームとして使用（外付けHDDみたい）<br>    →不要になれば削除できる<br>・AZ内で自動でレプリケート（複製）される → ハードに障害起きてもデータがなくならない<br>・ボリュームタイプの変更が可能<br>・容量の変更が可能 → 確保している容量に対して課金<br>・高い耐久性のスナップショット → S3に保存</p><h5 id="★スナップショット"><a href="#★スナップショット" class="headerlink" title="★スナップショット"></a>★スナップショット</h5><p>⇒ ある瞬間における対象の全体像を丸ごと写し取ったもの。ここから復元できる</p><h5 id="★S3に保存"><a href="#★S3に保存" class="headerlink" title="★S3に保存"></a>★S3に保存</h5><p>⇒複数のAZで冗長化されており、耐久性がイレブンナイン<br>→EBSのスナップショットもイレブンナイン（99.999999999%）<br>※EBS自体はEC2にアタッチしているので、そのAZが死＝EBS死という状況を避けるため</p><p>・ボリュームタイプの変更が可能</p><h5 id="★汎用SSD-→-16-000IOPS"><a href="#★汎用SSD-→-16-000IOPS" class="headerlink" title="★汎用SSD → 16,000IOPS"></a>★汎用SSD → 16,000IOPS</h5><h5 id="★プロビジョンドIOPS-SSD-→-16-000〜64-000IOPS"><a href="#★プロビジョンドIOPS-SSD-→-16-000〜64-000IOPS" class="headerlink" title="★プロビジョンドIOPS SSD → 16,000〜64,000IOPS"></a>★プロビジョンドIOPS SSD → 16,000〜64,000IOPS</h5><h5 id="★スループット最適化HDD-→-SSDほど性能要らないとき-※ルートボリュームとしてはNG"><a href="#★スループット最適化HDD-→-SSDほど性能要らないとき-※ルートボリュームとしてはNG" class="headerlink" title="★スループット最適化HDD → SSDほど性能要らないとき　※ルートボリュームとしてはNG"></a>★スループット最適化HDD → SSDほど性能要らないとき　※ルートボリュームとしてはNG</h5><h5 id="★Cloud-HDD-→-SSDほど性能が要らず、アクセス頻度が低いとき-※ルートボリュームとしてはNG"><a href="#★Cloud-HDD-→-SSDほど性能が要らず、アクセス頻度が低いとき-※ルートボリュームとしてはNG" class="headerlink" title="★Cloud HDD → SSDほど性能が要らず、アクセス頻度が低いとき ※ルートボリュームとしてはNG"></a>★Cloud HDD → SSDほど性能が要らず、アクセス頻度が低いとき ※ルートボリュームとしてはNG</h5><h5 id="★IOPS"><a href="#★IOPS" class="headerlink" title="★IOPS"></a>★IOPS</h5><p>⇒1秒あたりのディスクが処理できるI/Oアクセスの数<br>→SSDの性能</p><p>・ボリュームの暗号化 → スナップショットも暗号化。自動なので操作不要<br>・永続的ストレージ → インスタンスを再起動してもデータは残る</p><h5 id="★インスタンスストア"><a href="#★インスタンスストア" class="headerlink" title="★インスタンスストア"></a>★インスタンスストア</h5><p>⇒EBSの対比で、ホストのローカルのストレージを使うこと<br>→インスタンスの状態に依存する（データは一時的利用）</p><h5 id="AWS-マーケットプレイス"><a href="#AWS-マーケットプレイス" class="headerlink" title="AWS マーケットプレイス"></a>AWS マーケットプレイス</h5><p>AWS上で利用可能なソフトウェアやサービスを見つけ、購入することができるオンラインストアです。ここでAWS用のサードパーティのソフトウェアソリューションとサービスの検索することができます。</p><h5 id="S3-Simple-Storage-Service"><a href="#S3-Simple-Storage-Service" class="headerlink" title="S3 (Simple Storage Service)"></a>S3 (Simple Storage Service)</h5><p>⇒マネージド型のオブジェクトストレージ<br>・無制限のストレージ容量 → 容量の確保は必要なく、バケットさえ作ればOK<br>・高い耐久性 → 複数のAZ内で冗長化（イレブンナイン）<br>・ネット経由でアクセス → 世界のどこからでもアクセスできる</p><p>・バケット、オブジェクトはデフォルトでプライベート<br>・ACL（アクセスコントロールリスト）で簡単にアクセス権を設定できる<br>・バケットポリシーでより詳細にアクセス権を設定できる<br>・EC2などに、S3へのアクセスけんを設定する際はIAMロールを使用する<br>・HTTPSでアクセス可能。何もせずとも<br>・保存データの暗号化は複数の方法で可能 → S3キーでのサーバー、KMS、独自キーでのサーバーorクライアント</p><h5 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h5><p>ローカルまたは世界中のユーザーに提供するアプリケーションの可用性とパフォーマンスを改善します。AWS グローバルネットワークを使用してユーザーからアプリケーションへのパスを最適化し、TCP および UDP トラフィックのパフォーマンスを改善します。アプリケーションエンドポイントの状態を継続的に監視し、異常なエンドポイントを検出し、1 分以内に正常なエンドポイントにトラフィックをリダイレクトします。</p><h5 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h5><p>オンプレミスアプリケーションがAWSクラウドストレージをシームレスに接続することができるハイブリッドストレージサービスです。 このサービスはバックアップ、アーカイブ、災害復旧、クラウドデータ処理、および移行に使用できます。</p><h5 id="ストレージクラス"><a href="#ストレージクラス" class="headerlink" title="ストレージクラス"></a>ストレージクラス</h5><p>★標準 → デフォ</p><p>★低頻度アクセスストレージ（標準IA）→ リクエスト料金↑、ストレージ料金↓<br>　⇒バックアップデータに最適</p><p>★1ゾーン定頻度アクセスストレージ（1ゾーンIA）→複数のAZで冗長化されない。別リージョンでのバックアップ</p><p>★Amazon Glacier → 取り出しに3-5Hかかる。法的保存期間の定めがあるものなど<br>・ストレージ料金は、最適なストレージクラス選択によってコスト効率を高められる<br>・ライフサイクルポリシーによってストレージクラスの変更を自動化できる<br>・リージョン外へのアウト通信にのみ転送料金がかかる</p><h5 id="その他のストレージサービス"><a href="#その他のストレージサービス" class="headerlink" title="その他のストレージサービス"></a>その他のストレージサービス</h5><p>EFS (Amazon Elastic File System)<br>⇒複数のEC2インスタンスでマウントして共有利用できるファイルストレージサービス</p><h5 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h5><p>⇒オンプレアプリとAWSのストレージをシームレスに接続利用するためのゲートウェイ</p><h5 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h5><p>⇒物理デバイスを利用してペタ級の大容量データ転送を行うサービス</p><h4 id="ネットワーク"><a href="#ネットワーク" class="headerlink" title="ネットワーク"></a>ネットワーク</h4><h5 id="VPC-Virtual-Private-Cloud"><a href="#VPC-Virtual-Private-Cloud" class="headerlink" title="VPC (Virtual Private Cloud)"></a>VPC (Virtual Private Cloud)</h5><p>⇒AWS内に構築できるプライベートなネットワーク環境<br>→AWSの敷地の中で、「自分の領域はここ！」<br>・リージョンを選択して作成（AZをまたぐことはできる）<br>・CIDR (Classless Inter-Domain Routing) → プライベートIPの範囲を定義する</p><h5 id="★サブネット"><a href="#★サブネット" class="headerlink" title="★サブネット"></a>★サブネット</h5><p>⇒AZとIPアドレス範囲を定義するネットワークグループ<br>→役割別に作成する（外部接続係、内部接続係）</p><h5 id="★インターネットゲートウェイ"><a href="#★インターネットゲートウェイ" class="headerlink" title="★インターネットゲートウェイ"></a>★インターネットゲートウェイ</h5><p>★インターネットゲートウェイ<br>⇒VPCとパブリックインターネットを接続するためのGateway<br>→インターネット（外部との通信）の入り口<br>※入り口はVPCにつき一つ<br>※水平スケーリングによる冗長性を持っているので、単一障害点にはならない</p><h5 id="★ルートテーブル"><a href="#★ルートテーブル" class="headerlink" title="★ルートテーブル"></a>★ルートテーブル</h5><p>⇒サブネットの経路を設定。サブネットと関連づける<br>→通信に関するルールブック</p><h5 id="★セキュリティグループ"><a href="#★セキュリティグループ" class="headerlink" title="★セキュリティグループ"></a>★セキュリティグループ</h5><p>⇒仮想ファイアウォール<br>→セキュリティに関するルールブック<br>※送信元を、CIDRでIPアドレス範囲で指定<br>※送信元を、他のセキュリティグループのIDで指定<br>　→IPアドレスに依存せず、柔軟かつ最低限の送信元だけを許可するセキュアな設定<br>※VPCを指定して作成→トラフィックのホワイトリスト化</p><h5 id="★ネットワークACL-Access-Control-List"><a href="#★ネットワークACL-Access-Control-List" class="headerlink" title="★ネットワークACL(Access Control List)"></a>★ネットワークACL(Access Control List)</h5><p>⇒サブネットに対して設定する仮想ファイアウォール<br>・拒否するインバウンドのポートと送信元を設定するブラックリスト<br>・必要がなければ設定しない追加のセキュリティレイヤー</p><h5 id="★外部からEC2インスタンスにアクセスするための重要ポイント"><a href="#★外部からEC2インスタンスにアクセスするための重要ポイント" class="headerlink" title="★外部からEC2インスタンスにアクセスするための重要ポイント"></a>★外部からEC2インスタンスにアクセスするための重要ポイント</h5><p>・インターネットゲートウェイをVPCにアタッチ<br>・インターネットゲートウェイへの経路を持つルートテーブルをサブネットに関連づける<br>・EC2インスタンスをそのサブネット内で起動<br>・EC2インスタンスにパブリックIPアドレスを有効にする<br>（orEC2のパブリックIPを固定するElastic IPをアタッチする）</p><h5 id="★ハイブリッド環境構成"><a href="#★ハイブリッド環境構成" class="headerlink" title="★ハイブリッド環境構成"></a>★ハイブリッド環境構成</h5><p>・VPCに、既存のオンプレからVPN or 専用回線で接続<br>→オンプレ環境の拡張先としてAWS使える<br>⇒オンプレ＆クラウド＝ハイブリッド</p><h5 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h5><p>⇒コンテンツ配信ネットワークサービス(CDN = Contents Delivery Network)<br>・最も低いレイテンシーで配信できる<br>・キャッシュによる低レイテンシー配信 → エッジロケーションにキャッシュ持たせてる<br>・ユーザの近くからの低レイテンシー配信 → ユーザへは最もレイテンシーの低いエッジロケーションから配信<br>・安全性の高いセキュリティ → ドメイン証明書を設定できる＝HTTPS化</p><h5 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h5><p>⇒DNS(Domain Name System)サービス<br>→例えばドメイン(teshita.com)とElastic IP(51.1.1.1)を紐付ける<br>・エッジロケーションで使用される<br>・複数のDNSレコードを設定し、用途に応じて様々なルーティング機能を選択<br>・高可用性実現するヘルスチェックとフェイルオーバー → 複数のDNSレコードにより実現<br>・ルートドメイン(Zone Apex)のエイリアスレコード</p><h4 id="データベース"><a href="#データベース" class="headerlink" title="データベース"></a>データベース</h4><h5 id="AWS-OpsWorks"><a href="#AWS-OpsWorks" class="headerlink" title="AWS OpsWorks"></a>AWS OpsWorks</h5><p>Chef や Puppet のマネージド型インスタンスを利用した構成管理サービスです。Chef や Puppet は、コードを使用してサーバーの構成を自動化するためのオートメーションプラットフォームです。Puppetを使用してEC2インスタンスの構成方法を自動化することができます。</p><h5 id="RDS-Relational-Database-Service"><a href="#RDS-Relational-Database-Service" class="headerlink" title="RDS (Relational Database Service)"></a>RDS (Relational Database Service)</h5><p>⇒オンプレで使用されているデータベースエンジンをそのまま使えるDBサービス<br>・通常のデータベースタスクの時間を節約して、ユーザーに必要な高速パフォーマンスと高可用性を提供する</p><h5 id="★EC2にMySQLなどをインストールして使うのと違うのは"><a href="#★EC2にMySQLなどをインストールして使うのと違うのは" class="headerlink" title="★EC2にMySQLなどをインストールして使うのと違うのは"></a>★EC2にMySQLなどをインストールして使うのと違うのは</h5><p>・メンテナンス(OS、DBエンジンのアプデ)不要<br>・バックアップ不要 → 自動で行ってくれる(max35日間) →それを超えるときは手動のスナップショット<br>※ポイントタイムリカバリー → 自動バックアップ期間内なら、秒単位での指定復元可能<br>・高可用性の担保 → マルチAZ<br>　→MasterとStandby間でレプリケーション（異なるデータセンター間を低レイテンシーで実現）<br>※クロスリージョンリードレプリカ<br>　→リードレプリカを他リージョンに作成することで、マスターデータベースから読み込みの負荷を軽減できる</p><h5 id="★Amazon-Aurora"><a href="#★Amazon-Aurora" class="headerlink" title="★Amazon Aurora"></a>★Amazon Aurora</h5><p>⇒クラウドに最適化して再設計されたリレーショナルデータベースエンジン<br>→MySQL、PostgreSQL互換<br>・メリットある</p><h5 id="Amazon-Neptune"><a href="#Amazon-Neptune" class="headerlink" title="Amazon Neptune"></a>Amazon Neptune</h5><p>高速かつ信頼性の高いフルマネージドグラフデータベースサービスです。このサービスでは、高度に接続されたデータセットと連携するアプリケーションを簡単に構築および実行できます。Amazon Neptuneを利用することで、洗練されたインタラクティブなグラフアプリケーションを作成することができます。</p><h5 id="★DMS-Databese-Migration-Service"><a href="#★DMS-Databese-Migration-Service" class="headerlink" title="★DMS (Databese Migration Service)"></a>★DMS (Databese Migration Service)</h5><p>⇒DBの移行サービス<br>・オンプレからAWSへの継続的なデータ移行 → システムのダウンタイムを最小限にできる</p><h5 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h5><p>⇒NoSQL型のフルマネージドDB<br>→非リレーショナル<br>・テーブル名とプライマリーキーを決めるのみで、リージョン選択するだけで使える（AZ気にしない）<br>・RDSよりさらに管理範囲が少ない</p><h5 id="★RDSとの違い"><a href="#★RDSとの違い" class="headerlink" title="★RDSとの違い"></a>★RDSとの違い</h5><p>①スケーリング<br>・RDS → 垂直スケーリング → 性能の向上（数は一つ） →大量のアクセス🙅‍♂️(高速パフォーマンスと高可用性🙆‍♂️)<br>・DynamoDB → 水平スケーリング → 数の増加 → 大量のアクセス🙆‍♂️(厳密なトランザクション、複雑なクエリ🙅‍♂️)</p><p>②テーブルの型<br>・RDS → SQL型（Excelみたい）<br>・DynamoDB → NoSQL型（アイテム＝ハッシュ？）<br>→不定型の入れ物に自由に情報を格納 → キーを検索のインデックスとして扱う</p><h5 id="その他のデータベースサービス"><a href="#その他のデータベースサービス" class="headerlink" title="その他のデータベースサービス"></a>その他のデータベースサービス</h5><h5 id="★Amazon-Redshift"><a href="#★Amazon-Redshift" class="headerlink" title="★Amazon Redshift"></a>★Amazon Redshift</h5><p>⇒高速でシンプルなデータウェアハウスサービスで、分析に使用される</p><h5 id="★Amazon-ElasticCache"><a href="#★Amazon-ElasticCache" class="headerlink" title="★Amazon ElasticCache"></a>★Amazon ElasticCache</h5><p>⇒インメモリデータストアサービス<br>→クエリ結果のキャッシュやアプリのセッション情報を管理するのに使用される</p><h5 id="★Amazon-Nepture"><a href="#★Amazon-Nepture" class="headerlink" title="★Amazon Nepture"></a>★Amazon Nepture</h5><p>⇒グラフデータベースサービスで、関係性や相関情報などを扱う。提案エンジン、物流最適化など</p><h4 id="管理サービス"><a href="#管理サービス" class="headerlink" title="管理サービス"></a>管理サービス</h4><h5 id="Amazon-Cognito"><a href="#Amazon-Cognito" class="headerlink" title="Amazon Cognito"></a>Amazon Cognito</h5><p>ウェブアプリケーションやモバイルアプリケーションの認証、許可、ユーザー管理をサポートしています。ユーザーは、ユーザー名とパスワードを使用して直接サインインするか、Facebook、Amazon、Google などのサードパーティーを通じてサインインできます。</p><h5 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h5><p>⇒AWSサービスの情報をモニタリングするサービス<br>・標準(組込メトリクス)の収集、可視化<br>・カスタムメトリクスの収集、可視化<br>・ログの収集 → メトリクスだけでなくEC2などのログも収集できる<br>※これによりEC2をステートレスにできる → EC2ローカルにログファイルがあると障害時自動終了が面倒</p><h5 id="★標準メトリクス-→-AWSが管理する範囲の情報。サービスによって異なる"><a href="#★標準メトリクス-→-AWSが管理する範囲の情報。サービスによって異なる" class="headerlink" title="★標準メトリクス → AWSが管理する範囲の情報。サービスによって異なる"></a>★標準メトリクス → AWSが管理する範囲の情報。サービスによって異なる</h5><h5 id="★カスタムメトリクス-→-ユーザが管理する範囲の情報。CloudWatchエージェントで取得できる"><a href="#★カスタムメトリクス-→-ユーザが管理する範囲の情報。CloudWatchエージェントで取得できる" class="headerlink" title="★カスタムメトリクス → ユーザが管理する範囲の情報。CloudWatchエージェントで取得できる"></a>★カスタムメトリクス → ユーザが管理する範囲の情報。CloudWatchエージェントで取得できる</h5><h5 id="★CloudWatch-Logs-→-インスタンスのログを収集。CloudWatchエージェントで取得できる"><a href="#★CloudWatch-Logs-→-インスタンスのログを収集。CloudWatchエージェントで取得できる" class="headerlink" title="★CloudWatch Logs → インスタンスのログを収集。CloudWatchエージェントで取得できる"></a>★CloudWatch Logs → インスタンスのログを収集。CloudWatchエージェントで取得できる</h5><p>※文字列のフィルタリング結果をメトリクスとして扱える<br>※保存期間は任意。失効しないも可能</p><p>・アラームを設定することで、モニタリング結果に基づく運用を自動化できる</p><h5 id="AWS-Security-Token-Service-AWS-STS"><a href="#AWS-Security-Token-Service-AWS-STS" class="headerlink" title="AWS Security Token Service(AWS STS)"></a>AWS Security Token Service(AWS STS)</h5><p>AWS のサービスへのアクセスに使用できる一時的な限定権限認証情報を取得できます。一時的な認証情報は AWS STS によって生成されます。デフォルトでは、AWS STS は <a href="https://sts.amazonaws.com" target="_blank" rel="noopener">https://sts.amazonaws.com</a> に 1 つのエンドポイントのあるグローバルサービスです。ただし、他のサポートされているリージョンにあるエンドポイントへの AWS STS API 呼び出しを実行することもできます。</p><h5 id="Amazon-Elastic-Container-Registry-ECR"><a href="#Amazon-Elastic-Container-Registry-ECR" class="headerlink" title="Amazon Elastic Container Registry (ECR)"></a>Amazon Elastic Container Registry (ECR)</h5><p>開発者がDockerコンテナイメージをAWSクラウドに保存・管理することができます。ECRは完全マネージド型の Docker コンテナレジストリとして提供されています。</p><h5 id="Trusted-Advisor"><a href="#Trusted-Advisor" class="headerlink" title="Trusted Advisor"></a>Trusted Advisor</h5><p>⇒環境を自動でチェックし、ベストプラクティスに近づけるためのアドバイスをくれるサービス<br>・コスト最適化の視点<br>・パフォーマンスの視点 → 最適なサービス、サイズが選択されてるか？<br>・セキュリティ → リスクないか？<br>・フォールトトレランス（耐障害性）<br>・サービス制限 → 意図しない操作等で不利益が生じないようにするためのソフトリミット</p><h4 id="その他の管理ツール"><a href="#その他の管理ツール" class="headerlink" title="その他の管理ツール"></a>その他の管理ツール</h4><h5 id="★Cloud-Trail"><a href="#★Cloud-Trail" class="headerlink" title="★Cloud Trail"></a>★Cloud Trail</h5><p>⇒AWS内のすべてのAPI呼び出しを記録</p><h5 id="Cost-Explorer"><a href="#Cost-Explorer" class="headerlink" title="Cost Explorer"></a>Cost Explorer</h5><p>コストと使用状況を表示および分析するために使用できるツールです。メイングラフ、コストと使用状況レポート、または Cost Explorer RI レポートを使用して、使用状況とコストを確認できます。過去 13 か月までのデータを表示し、今後 3 か月間にどれくらい費やす可能性が高いかを予測し、リザーブドインスタンスを購入するための推奨事項を得ることができます。また、さらに調べる必要がある分野を特定し、コストを把握するために使用できる傾向を確認できます。</p><h5 id="★CloudFormation"><a href="#★CloudFormation" class="headerlink" title="★CloudFormation"></a>★CloudFormation</h5><p>⇒AWSの各リソースを含めた環境を自動作成／更新／管理</p><h5 id="★Elastic-Beanstalk"><a href="#★Elastic-Beanstalk" class="headerlink" title="★Elastic Beanstalk"></a>★Elastic Beanstalk</h5><p>⇒Webアプリの環境を簡単にAWSに構築<br>AWS クラウド上にアプリケーションをすばやくデプロイし、管理を自動化できます。これはGo、Java、.NET、Node.js、PHP、Python、Ruby で開発されたアプリケーションをサポートしており、.NETアプリケーションをAWSクラウドにすばやくデプロイすることが可能です。</p><h5 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h5><p>AWS でご利用のインフラストラクチャを可視化し、制御するためのサービスです。統一されたユーザーインターフェイスを介して複数のAWSサービスからの運用データを表示し、運用タスクを自動化することができます。</p><h5 id="★Cloud-Config"><a href="#★Cloud-Config" class="headerlink" title="★Cloud Config"></a>★Cloud Config</h5><p>⇒リソースの設定変更履歴を簡単に見れる</p><hr><h3 id="その他補足"><a href="#その他補足" class="headerlink" title="その他補足"></a>その他補足</h3><h5 id="Lambda-1"><a href="#Lambda-1" class="headerlink" title="Lambda"></a>Lambda</h5><p>新しい情報に迅速に対応できるアプリケーションを容易に構築できるコンピューティングサービスです。<br>これはサーバレスアプリケーションを利用する際にEC2の代わりに利用するサービスです。</p><h5 id="セキュリティグループ-1"><a href="#セキュリティグループ-1" class="headerlink" title="セキュリティグループ"></a>セキュリティグループ</h5><p>インスタンスに対して設定するホワイトリストの仮想FW</p><h5 id="ネットワークACL"><a href="#ネットワークACL" class="headerlink" title="ネットワークACL"></a>ネットワークACL</h5><p>サブネットに対して設定するブラックリストの仮想FW<br>着信トラフィックリクエストをフィルタリング</p><h5 id="オンデマンドインスタンス"><a href="#オンデマンドインスタンス" class="headerlink" title="オンデマンドインスタンス"></a>オンデマンドインスタンス</h5><p>一週間という期限だけで利用する場合はオンデマンドインスタンスを利用</p><h5 id="スポットインスタンス"><a href="#スポットインスタンス" class="headerlink" title="スポットインスタンス"></a>スポットインスタンス</h5><p>一瞬だけ使う。動画編集するときだけ、みたいな</p><h5 id="スケジュールドリザーブドインスタンス"><a href="#スケジュールドリザーブドインスタンス" class="headerlink" title="スケジュールドリザーブドインスタンス"></a>スケジュールドリザーブドインスタンス</h5><p>週一回金曜日や、１０時から１７時といった定期的な利用時間にかぎってインスタンスを利用する場合にコスト最適</p><h5 id="CloudTrail"><a href="#CloudTrail" class="headerlink" title="CloudTrail"></a>CloudTrail</h5><p>AWS内のすべてのAPI呼び出しを記録<br>AWSでのガバナンス、コンプライアンス、およびリスク監査のために、CloudTrailを有効化する必要<br>ユーザーアクティビティログを取得することができます。ユーザー、ロール、または AWS のサービスによって実行されたアクションは、CloudTrail にイベントとして記録されます。イベントには、AWS マネジメントコンソール、AWS CLI、および AWS SDK と API で実行されたアクションが含まれます。</p><h5 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h5><p>AWS Config はAWS リソースの設定を評価、監査、審査できるサービスです。Config では、AWS リソースの設定が継続的にモニタリングおよび記録され、望まれる設定に対する記録された設定の評価を自動的に実行できます。AWSリソース設定がコンプライアンスやガバナンス上最適な構成になっているかを評価・監視することができまます。</p><h5 id="AWS-Systems-Manager-1"><a href="#AWS-Systems-Manager-1" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h5><p>運用関連！<br>AWSで利用しているインフラストラクチャを可視化し、制御するためのサービス<br>アプリケーション、環境、リージョン、プロジェクト、キャンペーン、ビジネスユニット、ソフトウェアライフサイクルなど、選択した目的やアクティビティごとに AWS リソースをグループ化します。</p><p>AWS リソースに関連する運用作業項目を一元的に表示、調査、および解決します。<br>さまざまなメンテナンスおよびデプロイタスクを自動化またはスケジュールする<br>インフラストラクチャを可視化し、制御するためのサービス</p><p>統一されたユーザーインターフェイスを介して複数のAWSサービスからの運用データを表示し、運用タスクを自動化できる</p><h5 id="Access-Advisor"><a href="#Access-Advisor" class="headerlink" title="Access Advisor"></a>Access Advisor</h5><p>IAMエンティティ(ユーザー、グループ、ロール) が最後にAWSサービスにアクセスした⽇付と時刻を表⽰する機能</p><h5 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h5><p>EC2はアンマネージド型サービスの典型的なサービス<br>ユーザー側でインスタンスのオペレーティングシステムとアプリケーションに定期的にパッチを適用し、更新し、保護する必要がある</p><p>プレイスメントグループ<br>AZ内でインスタンスをまとめることで、低レイテンシーネットワークパフォーマンスを実現</p><h5 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h5><p>負荷分散機能<br>配下のEC2の負荷に応じて、複数のAZに跨るEC2インスタンスの負荷分散を行う機能</p><h5 id="Connection-Draining"><a href="#Connection-Draining" class="headerlink" title="Connection Draining"></a>Connection Draining</h5><p>インスタンスが登録解除されるか異常が発生した場合に、そのバックエンドインスタンスへの新規リクエスト送信を中止する機能</p><h5 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h5><p>事前に定義されたテンプレ―トに基づいて、EC2インスタンスを分析し、脆弱性をチェックすることができます。これにより、Amazon Inspector では、自動的にアプリケーションを評価し、露出、脆弱性、ベストプラクティスからの逸脱がないかどうかを確認できます。AWS にデプロイしたアプリケーションのセキュリティとコンプライアンスを向上させることができます。</p><ul><li><p>ヘルスチェック<br>EC2インスタンスの正常／異常を確認し、利用するEC2の振り分けを行う機能</p></li><li><p>スティッキーセッション<br>セッション中に、同じユーザから来たリクエストを全て、同じEC2インスタンスに送信する機能</p></li><li><p>ELBのターゲットグループを設定すれば、ELB構成されたEC2インスタンス群に対して、AutoScalingを設定することが可能</p></li></ul><h5 id="S3（オブジェクトストレージ）"><a href="#S3（オブジェクトストレージ）" class="headerlink" title="S3（オブジェクトストレージ）"></a>S3（オブジェクトストレージ）</h5><p>S3 Intelligent-Tiering<br>アクセスパターンを把握するために何らか特別な開発をする必要はなく、S3を有効活用</p><p>S3は直接リージョンに設置されるサービス</p><p>AZ間で自動的にデータを複製する</p><p>重要なデータを保存するための耐久性のあるインフラストラクチャを提供し、オブジェクトの99.999999999％の耐久性のために設計されています<br>データは、複数の施設と各施設の複数のデバイスに冗長的に保存されます。</p><h5 id="EBS-Elastic-Block-Store-：外付けHDD（ブロックストレージ）"><a href="#EBS-Elastic-Block-Store-：外付けHDD（ブロックストレージ）" class="headerlink" title="EBS (Elastic Block Store)：外付けHDD（ブロックストレージ）"></a>EBS (Elastic Block Store)：外付けHDD（ブロックストレージ）</h5><p>⇒EC2インスタンスにアタッチして使うブロックストレージボリューム<br>EC2のルートボリュームor追加ボリュームとして使用（外付けHDDみたい）<br>不要になれば削除できる<br>削除の挙動は都度設定できる</p><p>AZ内で自動でレプリケート（複製）される → ハードに障害起きてもデータがなくならない<br>ボリュームタイプの変更が可能<br>容量の変更が可能 → 確保している容量に対して課金<br>高い耐久性のスナップショット(EC2ボリュームをバックアップする機能) → S3に保存<br>スナップショットはそのEBSが設置されているリージョン内にスナップショットを作成<br>シングルリージョンのみに限定されず、スナップショットを他のリージョンにコピーすることで、他リージョンにおいて、スナップショットによる復元を実施できる</p><p>EBSのスナップショットは増分バックアップ<br>頻繁かつ詳細な更新が必要なデータのプライマリストレージデバイスとして使用</p><h5 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h5><ul><li><p>KMS：データを暗号化することができます</p></li><li><p>AMI： EBSスナップショット + α(管理情報)<br>  AMIの作成時点のEBSボリュームも復元できる＝スナップショットからだけでなく、AMIからも復元できる</p></li><li><p>EC2インスタンスを起動する際にボリュームタイプとしてEBSのストレスタイプを選択することが必須</p></li><li><p>EFS (Elastic File System)：NAS（ファイルストレージ）<br>  複数のEC2インスタンスでマウントして共有利用できるファイルストレージサービス<br>  EC2インスタンスからLAN上にあるNASとして利用できる共有ファイルストレージ<br>  インスタンスストア：Cドライブ<br>  EC2インスタンスの一時的なデータを保持するストレージ<br>  EBSの対比で、ホストのローカルのストレージを使うこと<br>  インスタンスの状態に依存する（データは一時的利用）<br>  AWS側で管理されるもの</p></li><li><p>Elastic IP<br>  利用されていないElastic IPがあると課金される<br>  課金発生しない条件<br>  Elastic IP アドレスが EC2 インスタンスに関連付けられている。<br>  Elastic IP アドレスに関連付けられているインスタンスが実行中である。<br>  インスタンスに 1 つの Elastic IP アドレスしか添付されていない。</p></li><li><p>ElasticCache<br>  クラウド内のインメモリデータストアまたはキャッシュを簡単にデプロイ、操作、およびスケーリングできるようにするウェブサービス<br>  ミリ秒未満のレイテンシを必要とするリアルタイムIoTアプリケーションのデータ処理に利用</p></li><li><p>Amazon Redshift<br>  高速でシンプルなデータウェアハウスサービスで、分析に使用される<br>  通常の業務システムデータなどのBIシステムやデータウェアハウスとして利用可能なリレーショナルデータベースサービスです<br>  AWSが提供するフルマネージド型サービスであり、ペタバイト規模のデータを扱う性能を有しています</p></li><li><p>Aurora<br>  Auroraの DB インスタンスでは常に自動バックアップが有効<br>  クラウドに最適化して再設計されたリレーショナルデータベースエンジン<br>  MySQL、PostgreSQL互換<br>  可用性は99.99%<br>  最大15のリードレプリカを利用した高速読み込みが可能</p></li><li><p>Snowball Edge<br>  AWSクラウドへの安全な大量データの転送を可能にするサービス（ペタ）<br>  Snowballは古いサービスなので非推奨<br>  切断された環境における高度な機械学習およびフルモーションビデオ分析にも利用される<br>  AWSクラウドの一部をカーブアウトする（切り出す）ことができるサービス</p></li><li><p>VPC<br>  VPCを使用することで、AWSクラウドの一部をカーブアウトして定義した仮想ネットワークにAWSリソースを起動することができます。 この仮想ネットワークは、AWSのスケーラブルなインフラストラクチャを使用する利点を備え、独自のデータセンターで運用する従来のネットワークに非常に似ています。</p></li><li><p>Glacier<br>  取り出しに3-5Hかかる。法的保存期間の定めがあるものなど<br>  マルチAZ構成のフォールトトレランス（耐障害性）を考慮して設計されているAWSサービス<br>  AZ間で自動的にデータを複製する、ってこと？</p></li></ul><ul><li><p>DynamoDB<br>  AWSで実証された高可用性データセンターで実行されます。<br>  このサービスは、AWSリージョンの3つの施設にデータを複製し、サーバー障害またはアベイラビリティーゾーンの停止が発生した場合のフォールトトレランスを提供します。<br>  NoSQL型のフルマネージドDB<br>  非リレーショナル<br>  NoSQL型のkey-value およびドキュメントデータベース<br>  テーブル名とプライマリーキーを決めるのみで、リージョン選択するだけで使える（AZ気にしない）<br>  RDSよりさらに管理範囲が少ない<br>  プッシュボタンスケーリングにより、稼働を停止させることなく、設定オプションをワンクリックするだけでダウンタイムなしに、いつでもDBをスケーリングできます<br>  他のすべてのデータベースはEC2インスタンスに基づいているため、インスタンスのサイズを拡大してダウンタイムを招く</p></li><li><p>Amazon DynamoDB Accelerator (DAX)<br>  リクエストのレイテンシをミリ秒からマイクロ秒に短縮する機能</p></li><li><p>DynamoDB Streams<br>  DynamoDBによるクロスリージョンレプリケーションを行うために必要<br>  セッションデータを高速で管理するデータベース処理<br>  規模に関係なく数ミリ秒台のパフォーマンスを実現<br>  AZ間でデータを自動的に複製するサービス<br>  初めからマルチAZ構成のフォールトトレランスを考慮して設計されている<br>  利用負荷があらかじめ予測できる場合　⇒　プロビジョンドスループット<br>  利用負荷があらかじめ予測できない場合　⇒　オンデマンドキャパシティーモード</p></li><li><p>RDS (Relational Database Service)<br>  高速パフォーマンスと高可用性を提供するリレーショナルデータベース<br>  自動バックアップ(自動スナップショット)の機能<br>  リードレプリカ</p><pre><code>データの冗長性を実現し、コスト最適に災害復旧対応を実現する機能データベース (DB) インスタンスのパフォーマンスと耐久性が向上します。この機能によって、1 つの DB インスタンスのキャパシティーを伸縮自在にスケールし、読み取り頻度の高いデータベースのワークロードを緩和できます。ソース DB インスタンスのレプリカを複数作成し、アプリケーションの大容量読み取りトラフィックをデータの複数のコピーから提供することにより、全体の読み込みスループットを向上させることができます。リージョンは必要な場合、リードレプリカをスタンドアロンの DB インスタンスに昇格させることで、RDSに対してデータの冗長性を実現し、災害復旧を改善することができます</code></pre><p>  自動フェールオーバーを実行する機能<br>  マルチAZ構成<br>  マルチ AZ 配置を使用して DB インスタンスの高可用性およびフェイルオーバーサポートを提供<br>  RDSは利用している途中でインスタンスタイプを縮小することができます<br>  RDS リードレプリカ<br>  RDSに対してデータの冗長性を実現し、コスト最適に災害復旧対応を実現する機能<br>  RDSに対してデータベース読み取りアクティビティのオフロードを許可する機能</p></li><li><p>Organizations<br>  アカウントの作成を自動化し、ビジネスニーズを反映したアカウントのグループを作成し、それらのグループにポリシーを適用して管理できます。<br>  これにより、開発者向けのAWSアカウントの作成を自動化し、それらのアカウントのエンティティに必要なAWSサービスへのアクセスのみを許可するために、独自のOUを設定して、SCPによって管理することができます。<br>  単一の組織内の複数のAWSアカウントの支払いを統合</p></li><li><p>S3 Transfer Acceleration<br>  クライアントとAmazon S3バケット間の長距離にわたるファイルの高速かつ安全な転送を可能にする際に、利用するべき機能</p></li><li><p>AWS WAF (Web Application Firewall)<br>  ⇒Webアプリケーションのファイアウォール<br>  可用性低下、セキュリティ侵害、リソースの過剰消費など一般的なWebの脆弱性からアプリを保護する<br>  基本量は無料だが、セキュリティルールに基づいて課金<br>  セキュリティルールの設定が必要<br>  適用先は、CloudFront/Application Load Balancer/API Gatewayから選択</p></li><li><p>AWS Shield<br>  DDoS攻撃に対する保護サービス<br>  StandardプランとAdvancedプラン(AWS WAFが無償で無制限に利用可能)がある<br>  エッジロケーションで使用<br>  インフラに対するファイアウォール<br>  EC2上のアプリのセキュリティ・コンプライアンス向上のための脆弱性診断サービス<br>  自動でアプリを診断し、問題をリスト化</p></li><li><p>Amazon EMR(Elastic Map Reduce)<br>  ビッグデータのセットを分析および処理するために利用するサービス<br>  Apache Hadoop や Apache Spark などのビッグデータフレームワークとして、大量のデータを処理および分析するマネージド型クラスタープラットフォーム<br>  クラウドネイティブなビッグデータプラットフォーム<br>  MACHINE LEARNING<br>  抽出、変換、読み込み (ETL)<br>  クリックストリーム分析<br>  リアルタイムストリーミング<br>  インタラクティブ分析<br>  ゲノミクス</p></li><li><p>Amazon Kinesis<br>  ストリーミングデータをリアルタイムで収集、処理、分析する</p></li><li><p>Amazon Athena<br>  SQLの分析<br>  インタラクティブなクエリサービスで、Amazon S3 内のデータを標準 SQL を使用して簡単に分析</p></li><li><p>AWS SDK<br>  各言語に対応したAWS SDKを選択しすることで、選択したプログラミング言語を使用して、AWS でアプリケーションを簡単に開発することができます。</p></li><li><p>CloudFront<br>  高速コンテンツ配信ネットワーク (CDN) サービス<br>  グローバルに利用されるWEBアプリケーションのコンテンツを最適に提供するためにはCloudFrontによるコンテンツ配信を実施することが最適な構成<br>  課金対象</p><pre><code>トラフィックの分散データ転送とリクエストの価格は地域によって異なり、価格はコンテンツが配信されるエッジの場所に基づいています。</code></pre><p>  リクエスト</p><pre><code>リクエスト（HTTPまたはHTTPS）の数と種類、およびリクエストが行われた地域。</code></pre><p>  データ転送アウト</p><pre><code>Amazon CloudFrontエッジロケーションから転送されたデータの量。</code></pre><p>  ルーティングはしない</p></li><li><p>コンバーティブル<br>  リザーブドインスタンスのコンバーティブルは変更とインスタンス自体の交換が可能です。リザーブドインスタンスと同等な価格のリザーブドインスタンスのに交換できるため、より柔軟に変更できます。したがって、オプション１が正解となります。</p><p>  リザーブドインスタンスのコンバーティブルはインスタンスファミリー、オペレーティングシステム、およびテナンシーを含む別の構成で、1 つ以上の別の コンバーティブルリザーブドインスタンス の コンバーティブルリザーブドインスタンス に交換することもできます。交換先の コンバーティブルリザーブドインスタンス が交換元の コンバーティブルリザーブドインスタンス と同等あるいはそれ以上の値である限り、交換の実行回数に制限はありません。</p><p>  コンバーティブルリザーブドインスタンス を交換する場合、現在の予約のインスタンスの数はターゲットの コンバーティブルリザーブドインスタンス の設定と同じあるいはそれ以上の値を含有する数のインスタンスと交換されます。Amazon EC2 は、交換で受け取った リザーブドインスタンス の数を計算します。</p><p>  一方でリザーブドインスタンスのスタンダードは以下のような属性を変更することが可能です。</p><pre><code>・アベイラビリティーゾーンまたは適用範囲・ネットワークプラットフォーム (EC2-Classic または VPC)・インスタンスサイズ（Linuxのみ）</code></pre></li><li><p>AWSリソースが不正処理の例<br>  AWSリソースが不正処理に使用されている場合、AWS不正使用対策チームに連絡することが求められています。不正処理の例は次の通りです。</p><pre><code>✔スパム: AWS 所有の IP アドレスから不要なメールが届く、または AWS リソースがスパムウェブサイトやフォーラムに使用されている。✔ポートスキャニング: ログに、1 つ以上の AWS 所有の IP アドレスがサーバー上の複数のポートにパケットを送信していることが示されており、セキュリティで保護されていないポートを検出しようとしていると考えられる。✔サービス拒否攻撃 (DOS): ログに、1 つ以上の AWS 所有の IP アドレスがリソースのポートをパケットで溢れさせるために使用されていることが示されている。✔侵入の試み: ログに、1 つ以上の AWS 所有の IP アドレスがリソースへのログイン試行に使用されていることが示されている。✔不快なコンテンツや著作権で保護されたコンテンツのホスティング: AWS リソースが著作権者の同意なしに、違法コンテンツをホストまたは配布している。✔マルウェア配信: インストール先のコンピュータやマシンに不正アクセスしたり危害を加えるために意図的に作成されたソフトウェアを配布するために、AWS リソースが使用されている証拠がある。</code></pre></li><li><p>Amazon CloudFront<br>  AWSからのデータ転送アウトと、ユーザーからのリクエストとトラフィック分散に基づいて料金が決まります。</p><pre><code>-トラフィックの分散：データ転送とリクエストの価格は地域によって異なり、価格はコンテンツが配信されるエッジの場所に基づいている-リクエスト：リクエスト（HTTPまたはHTTPS）の数と種類、およびリクエストが行われた地域-データ転送アウト：Amazon CloudFrontエッジロケーションから転送されたデータの量。-機密データのセキュリティを高めたい場合には、データ転送時にSSLを使用するか、クライアントサイド暗号化を使用することで、転送中のデータを保護できます。</code></pre></li><li><p>Amazon S3<br>  保存データを保護するため次のような対応ができます。</p><pre><code>■サーバーサイド暗号化を有効化することで保存されるデータが暗号化されます。したがって、オプション２が正解となります。■クライアントサイド暗号化を使用することで、事前に暗号化されたデータをAmazon S3にアップロードできます。したがって、オプション３が正解となります。</code></pre></li><li><p>カスタムコンソール<br>  各フェーズに応じたカスタムコンソールを作成するには、各フェーズや領域のすべてのリソースをグループとして管理することが必要となります。デフォルトでは、AWSマネジメントコンソールはAWSサービスごとに整理されています。ただし、リソースグループツールを使用すると、プロジェクトと使用するリソースに基づいて情報を整理および統合するカスタムコンソールを作成できます。</p></li><li><p>RDS<br>  RDSはDBインスタンス、保存データ、自動バックアップとスナップショットを暗号化することができます。<br>  RDSは利用している途中でインスタンスタイプを縮小することができます。</p></li><li><p>Amazon DynamoDB Accelerator (DAX)<br>  フルマネージド型高可用性インメモリキャッシュで、DynamoDB 用に特化しています。1 秒あたりのリクエスト数が数百万件になる場合でも、ミリセカンドからマイクロセカンドへと最大 10 倍のパフォーマンス向上を実現します。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AWS 云从业者基础知识 学习笔记汇总&lt;/p&gt;
    
    </summary>
    
    
      <category term="aws" scheme="https://kisky3.github.io/tags/aws/"/>
    
      <category term="AWS Certified Cloud Practitioner" scheme="https://kisky3.github.io/tags/AWS-Certified-Cloud-Practitioner/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6 Error:All mirror URLs are not using ftp, http[s] or file.</title>
    <link href="https://kisky3.github.io/2021/02/23/CentOS6Error/"/>
    <id>https://kisky3.github.io/2021/02/23/CentOS6Error/</id>
    <published>2021-02-22T16:20:34.000Z</published>
    <updated>2021-09-18T15:02:06.959Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS6 Error: All mirror URLs are not using ftp, http[s] or file.</p><a id="more"></a><p>2020-11-30开始CentOS 6已经不支持了！</p><p>如果<code>yum install</code>和<code>yum update</code>的时候出现以下的错误的话要考虑看是不是CentOS6版本不支持了的缘故.</p><p>error:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Loaded</span> <span class="selector-tag">plugins</span>: <span class="selector-tag">fastestmirror</span>, <span class="selector-tag">ovl</span></span><br><span class="line"><span class="selector-tag">Setting</span> <span class="selector-tag">up</span> <span class="selector-tag">Install</span> <span class="selector-tag">Process</span></span><br><span class="line"><span class="selector-tag">Error</span>: <span class="selector-tag">Cannot</span> <span class="selector-tag">retrieve</span> <span class="selector-tag">repository</span> <span class="selector-tag">metadata</span> (<span class="selector-tag">repomd</span><span class="selector-class">.xml</span>) <span class="selector-tag">for</span> <span class="selector-tag">repository</span>: <span class="selector-tag">base</span>. <span class="selector-tag">Please</span> <span class="selector-tag">verify</span> <span class="selector-tag">its</span> <span class="selector-tag">path</span> <span class="selector-tag">and</span> <span class="selector-tag">try</span> <span class="selector-tag">again</span></span><br><span class="line"><span class="selector-tag">YumRepo</span> <span class="selector-tag">Error</span>: <span class="selector-tag">All</span> <span class="selector-tag">mirror</span> <span class="selector-tag">URLs</span> <span class="selector-tag">are</span> <span class="selector-tag">not</span> <span class="selector-tag">using</span> <span class="selector-tag">ftp</span>, <span class="selector-tag">http</span><span class="selector-attr">[s]</span> <span class="selector-tag">or</span> <span class="selector-tag">file</span>.</span><br><span class="line">Eg. Invalid release/repo/arch combination/</span><br><span class="line">removing mirrorlist with no valid mirrors: /var/cache/yum/x86_64/6/base/mirrorlist.txt</span><br></pre></td></tr></table></figure><p>自己是因为docker的关系一直用着旧的image和container,所以一直没有发觉. 一旦清空重新<code>docker compose up</code>的时候就因为CentOS6的关系当掉了.</p><p>解决方法是搜索最新所支持的包的url并替换掉…<br>或者将docker file里的CentOS版本更新.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS6 Error: All mirror URLs are not using ftp, http[s] or file.&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="CentOS6" scheme="https://kisky3.github.io/tags/CentOS6/"/>
    
  </entry>
  
  <entry>
    <title>Basic Operations on DynamoDB Tables by node.js</title>
    <link href="https://kisky3.github.io/2021/02/08/Node-js%E3%81%A7DynamoDB%E3%81%AE%E6%93%8D%E4%BD%9C/"/>
    <id>https://kisky3.github.io/2021/02/08/Node-jsでDynamoDBの操作/</id>
    <published>2021-02-07T15:04:54.000Z</published>
    <updated>2021-09-18T15:02:08.094Z</updated>
    
    <content type="html"><![CDATA[<p>用node.js对DynamoDB进行的基本操作</p><a id="more"></a><p>用js对DynamoDB进行数据操作的话有两种方法,<br>一种是使用AWS.DynamoDB,另一种是使用AWS.DynamoDB.DocumentClient(docClient)</p><p>例：AWS.DynamoDB</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dynamodb = <span class="keyword">new</span> AWS.DynamoDB();</span><br><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'DogTable'</span>,</span><br><span class="line">    Item:&#123;</span><br><span class="line">        <span class="string">'dogId'</span>:&#123;<span class="attr">N</span>: <span class="string">'12'</span>&#125;, <span class="comment">// 数字的情况下需要指定N</span></span><br><span class="line">        <span class="string">'name'</span>:&#123;<span class="attr">S</span>: <span class="string">'项羽'</span>&#125; <span class="comment">// 字符串的情况下要指定S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">dynamodb.putItem(params, callback);</span><br></pre></td></tr></table></figure><p>例：AWS.DynamoDB.DocumentClient</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docClient = <span class="keyword">new</span> AWS.DynamoDB.DocumentClient();</span><br><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'DogTable'</span>,</span><br><span class="line">    Item:&#123;</span><br><span class="line">         dogId: <span class="number">12</span>,</span><br><span class="line">         name: <span class="string">'项羽'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">docClient.put(params, callback);</span><br></pre></td></tr></table></figure><p>使用docClient的话,能够直接把原生的js代码转换成DynamoDB上的数据类型,代码相对简洁。<br>因此在此只讨论docClient的情况。</p><hr><h3 id="PUT-插入数据"><a href="#PUT-插入数据" class="headerlink" title="PUT (插入数据)"></a>PUT (插入数据)</h3><p>往SuperCarTable表里的主键(carId)里插入12这个项目。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'SuperCarTable'</span>,</span><br><span class="line">    Item:&#123;                               <span class="comment">// 主键是必须的（如果有排序键的话写上排序键）</span></span><br><span class="line">         carId: <span class="number">12</span>,                      <span class="comment">// 主键</span></span><br><span class="line">         name: <span class="string">'フェラーリ458'</span>,</span><br><span class="line">         price: <span class="number">28300000</span>,</span><br><span class="line">         engine: &#123;</span><br><span class="line">             type: <span class="string">'V型8気筒'</span>,</span><br><span class="line">             power: <span class="number">578</span></span><br><span class="line">         &#125;,</span><br><span class="line">         color:[<span class="string">'red'</span>, <span class="string">'black'</span>, <span class="string">'white'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">docClient.put(params, callback);</span><br></pre></td></tr></table></figure><hr><h3 id="GET（获取数据）"><a href="#GET（获取数据）" class="headerlink" title="GET（获取数据）"></a>GET（获取数据）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'SuperCarTable'</span>,</span><br><span class="line">    Key:&#123; <span class="comment">// 指定你想取得数据的主键(或者排序键)</span></span><br><span class="line">         carId: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">docClient.get(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.Item.name);       <span class="comment">//'宝马458'</span></span><br><span class="line">        <span class="built_in">console</span>.log(data.Item.engine.type);<span class="comment">//'V型8号引擎'</span></span><br><span class="line">        <span class="built_in">console</span>.log(data.Item.color[<span class="number">2</span>]);   <span class="comment">//'白色'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE(更新)"></a>UPDATE(更新)</h3><p>更新SuperCarTable表里主键(carId)为12的数据的其他属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'SuperCarTable'</span>,</span><br><span class="line">    Key:&#123;  <span class="comment">// 指定你想取得数据的主键(或者排序键)</span></span><br><span class="line">         carId: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 指定UpdateExpression的更新名</span></span><br><span class="line">    ExpressionAttributeNames: &#123;</span><br><span class="line">        <span class="string">'#n'</span>: <span class="string">'name'</span>,</span><br><span class="line">        <span class="string">'#d'</span>: <span class="string">'designer'</span></span><br><span class="line">        <span class="string">'#e'</span>: <span class="string">'engine'</span>,</span><br><span class="line">        <span class="string">'#t'</span>: <span class="string">'type'</span>,</span><br><span class="line">        <span class="string">'#p'</span>: <span class="string">'power'</span>,</span><br><span class="line">        <span class="string">'#c'</span>: <span class="string">'color'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 更新各属性的值</span></span><br><span class="line">    ExpressionAttributeValues: &#123;</span><br><span class="line">        <span class="string">':newName'</span>: <span class="string">'フェラーリ488GTB'</span>,</span><br><span class="line">        <span class="string">':newdesigner'</span>: <span class="string">'フラビオ・マンツォーニ'</span>,</span><br><span class="line">        <span class="string">':newType'</span>: <span class="string">'V型8気筒ツインターボ'</span>,</span><br><span class="line">        <span class="string">':addPower'</span>: <span class="number">92</span>,</span><br><span class="line">        <span class="string">':newColor'</span>: [<span class="string">'yellow'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    UpdateExpression: <span class="string">'SET #n = :newName, #d = :newDesigner, #e.#t = :newType, #e.#p = #e.#p + :addPower, #c = list_append(#c, :addPower)'</span></span><br><span class="line">&#125;;</span><br><span class="line">docClient.update(params, callback);</span><br></pre></td></tr></table></figure><h4 id="关于UpdateExpression"><a href="#关于UpdateExpression" class="headerlink" title="关于UpdateExpression"></a>关于UpdateExpression</h4><p>UpdateExpression是根据定义好的String的定义式来指定更新内容的。<br>必须要在UpdateExpression的最开始使用指定的action keyword,用逗号隔开的话可以同时执行多个指令。但是每个指定只能在一个UpdateExpression里使用一次。</p><p>例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UpdateExpression: <span class="string">'SET #a = :aval, #b = :bval REMOVE #c'</span></span><br></pre></td></tr></table></figure><h4 id="SET-ACTION"><a href="#SET-ACTION" class="headerlink" title="SET ACTION:"></a>SET ACTION:</h4><p>用于属性的追加和加工。比如对数值进行处理后追加,还可以在数列里添加数据。(数列时要使用[]将数据框起来)</p><h4 id="REMOVE-ACTION"><a href="#REMOVE-ACTION" class="headerlink" title="REMOVE ACTION:"></a>REMOVE ACTION:</h4><p>删除指定项目的指定属性, 也可以只删除指定数列内的数据。</p><p>例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpressionAttributeNames:&#123;</span><br><span class="line">    <span class="string">'#pr'</span>: <span class="string">'price'</span>,</span><br><span class="line">    <span class="string">'#c'</span>: <span class="string">'color'</span></span><br><span class="line">&#125;</span><br><span class="line">UpdateExpression: <span class="string">'REMOVE #pr, #c[1]'</span> <span class="comment">// 删除price属性和color数列的第二个值</span></span><br></pre></td></tr></table></figure><hr><h4 id="ADD-ACTION"><a href="#ADD-ACTION" class="headerlink" title="ADD ACTION:"></a>ADD ACTION:</h4><p>用于数值属性的加法处理,追加SET类型的值。(推荐用SET ACTION进行代替)<br>另外,SET类型是原生Javascirpt不存在的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionAttributeNames:&#123;</span><br><span class="line">    <span class="string">'#pr'</span>: <span class="string">'price'</span>,</span><br><span class="line">    <span class="string">'#c'</span>: <span class="string">'color'</span><span class="comment">// color属性为String Set型</span></span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeValues:&#123;</span><br><span class="line">    <span class="string">':addPrice'</span>: <span class="number">7400000</span>,  <span class="comment">// 为price属性加上7400000</span></span><br><span class="line">    <span class="string">':addColor'</span>: docClient.createSet([<span class="string">'Yellow'</span>, <span class="string">'Gray'</span>]) <span class="comment">// 为color属性添加Yellow和Gray的值</span></span><br><span class="line">&#125;,</span><br><span class="line">UpdateExpression: <span class="string">'ADD #pr :addPrice, #c :addColor'</span></span><br></pre></td></tr></table></figure><hr><h4 id="DELETE-ACTION"><a href="#DELETE-ACTION" class="headerlink" title="DELETE ACTION:"></a>DELETE ACTION:</h4><p>可以从SET型的属性删除指定的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExpressionAttributeNames:&#123;</span><br><span class="line">    <span class="string">'#c'</span>: <span class="string">'color'</span> <span class="comment">// color属性为String Set型</span></span><br><span class="line">&#125;,</span><br><span class="line">ExpressionAttributeValues:&#123;</span><br><span class="line">    <span class="string">':deleteColor'</span>: docClient.createSet([<span class="string">'Red'</span>, <span class="string">'Blue'</span>])  <span class="comment">// 从color属性删除Red和Blue的值</span></span><br><span class="line">&#125;,</span><br><span class="line">UpdateExpression: <span class="string">'DELETE #pr :deletePrice'</span></span><br></pre></td></tr></table></figure><p>如果是删除指定的一列数据的话,可以直接使用delete。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'SuperCarTable'</span>,</span><br><span class="line">    Key:&#123;   <span class="comment">// 指定想删除项目的主键(或排序键)</span></span><br><span class="line">         carId: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">docClient.delete(params, callback);</span><br></pre></td></tr></table></figure><hr><h4 id="QUERY-检索-和SCAN-取得所有"><a href="#QUERY-检索-和SCAN-取得所有" class="headerlink" title="QUERY(检索)和SCAN(取得所有)"></a>QUERY(检索)和SCAN(取得所有)</h4><p>QUERY:<br>基本情况下,表的主键和排序键(或者两者同时)的情况下才能进行query。<br>但是如果使用了<em>GSI</em>的情况下,也可以利用其他的属性来进行检索。</p><p>GSI:</p><table><thead><tr><th>name(pk)</th><th>year(sk)</th><th>category</th><th>nation</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>例:</p><h4 id="对1980年前获奖的获奖者进行query。"><a href="#对1980年前获奖的获奖者进行query。" class="headerlink" title="对1980年前获奖的获奖者进行query。"></a>对1980年前获奖的获奖者进行query。</h4><p>这时query的对象是sort key,所以直接可以进行query</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'NovelPrizeTable'</span>,</span><br><span class="line">    ExpressionAttributeNames:&#123;<span class="string">'#y'</span>: <span class="string">'year'</span>&#125;,</span><br><span class="line">    ExpressionAttributeValues:&#123;<span class="string">':val'</span>: <span class="number">1980</span>&#125;,</span><br><span class="line">    KeyConditionExpression: <span class="string">'#y &lt;= :val'</span><span class="comment">//検索対象が満たすべき条件を指定</span></span><br><span class="line">&#125;;</span><br><span class="line">docClient.query(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       data.Items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">person, index</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(person.name);<span class="comment">//1980年以前の受賞者の名前</span></span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h4 id="对获得经济学奖的获奖人进行query"><a href="#对获得经济学奖的获奖人进行query" class="headerlink" title="对获得经济学奖的获奖人进行query"></a>对获得经济学奖的获奖人进行query</h4><p>这时进行query的对象是category。所以要设置一个将category作为主键的GSI(Global secondary index)</p><ol><li>打开DynamoDB的控制台里的index tab.</li><li>生成index</li><li>主键里输入「category」,将数据类型选择为字符串.</li><li>sort key 可以不用填写.</li><li>index名可以设置为「category-index」</li><li>点击生成index.</li></ol><p>代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">    TableName: <span class="string">'NovelPrizeTable'</span>,</span><br><span class="line">    IndexName: <span class="string">'category-index'</span>,<span class="comment">//インデックス名を指定</span></span><br><span class="line">    ExpressionAttributeNames:&#123;<span class="string">'#c'</span>: <span class="string">'category'</span>&#125;,</span><br><span class="line">    ExpressionAttributeValues:&#123;<span class="string">':val'</span>: <span class="string">'economics'</span>&#125;,</span><br><span class="line">    KeyConditionExpression: <span class="string">'#c = :val'</span><span class="comment">//検索対象が満たすべき条件を指定</span></span><br><span class="line">&#125;;</span><br><span class="line">docClient.query(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       data.Items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">person, index</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(person.name);<span class="comment">//経済学賞受賞者の名前</span></span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="GSI-query的时候对IAM-Role的设置"><a href="#GSI-query的时候对IAM-Role的设置" class="headerlink" title="GSI query的时候对IAM Role的设置"></a>GSI query的时候对IAM Role的设置</h3><p>为了获得对<code>NovelPrizeTable</code>的操作权限, <code>NovelPrizeTable</code>的ARN操作时要分配到可以拥有操作权限的IAMRole.<br>但是NovelPrizeTable的GSI进行query的时候，必须要追加对当前的GSI的ARN的操作权限的Resource.<br>这时IAM Role的设置如下(表名字的后面添加/index(index名))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">    <span class="string">"Statement"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">            <span class="string">"Action"</span>: [</span><br><span class="line">                <span class="string">"dynamodb:Query"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Resource"</span>: [</span><br><span class="line">                <span class="string">"arn:aws:dynamodb:ap-northeast-1:********:table/NovelPrizeTable"</span>,</span><br><span class="line">                <span class="string">"arn:aws:dynamodb:ap-northeast-1:********:table/NovelPrizeTable/index/category-index"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用node.js对DynamoDB进行的基本操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://kisky3.github.io/tags/AWS/"/>
    
      <category term="DynamoDB" scheme="https://kisky3.github.io/tags/DynamoDB/"/>
    
      <category term="Node.js" scheme="https://kisky3.github.io/tags/Node-js/"/>
    
      <category term="DocumentClient" scheme="https://kisky3.github.io/tags/DocumentClient/"/>
    
  </entry>
  
  <entry>
    <title>How To Design Your Github Page</title>
    <link href="https://kisky3.github.io/2021/02/06/HowToDesignYourGithubPage/"/>
    <id>https://kisky3.github.io/2021/02/06/HowToDesignYourGithubPage/</id>
    <published>2021-02-06T10:37:26.000Z</published>
    <updated>2021-09-18T15:02:07.439Z</updated>
    
    <content type="html"><![CDATA[<p>如何美化设计你的Github主页</p><a id="more"></a><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>看见别人的 Github 和平常不太一样，通过搜索才知道可以通过建立和用户名相同的仓库展示到主页，丰富主页。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><ol><li>创建与 GitHub 账户同名的仓库，并勾选 README<img src="./1.png" style="width: 500px"></li></ol><p>从上图可以看到提示：</p><blockquote><p>You found a secret! Kisky3/Kisky3 is a ✨special ✨ repository that you can use to add a README.md to your GitHub profile. Make sure it’s public and initialize it with a README to get started.</p></blockquote><p>创建成功后返回主页查看效果,到此你会不会好奇这是怎样实现的，不妨我们查看下此仓库中唯一的README.md文件。</p><p>细心的你可以发现主页展示的内容就是此文件中的内容，并且 Github 官方也调皮的为你隐藏了提示。</p><h3 id="美化主页"><a href="#美化主页" class="headerlink" title="美化主页"></a>美化主页</h3><p>美化的思路就是通过改变与 GitHub 账户同名的仓库中的README.md文件，在主页展示不同的效果。</p><ol><li>引入GitHub 统计卡片</li></ol><p>项目地址：<a href="https://github.com/anuraghazra/" target="_blank" rel="noopener">https://github.com/anuraghazra/</a><br>readme 文件中已有详细的使用说明</p><p>更多效果，这就和编写网页一样，后面请尽情发挥。。。</p><p>最终效果如下：<br><img src="./2.png" style="width: 500px"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何美化设计你的Github主页&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end Knowledge" scheme="https://kisky3.github.io/categories/Front-end-Knowledge/"/>
    
    
      <category term="Github" scheme="https://kisky3.github.io/tags/Github/"/>
    
      <category term="Theme" scheme="https://kisky3.github.io/tags/Theme/"/>
    
  </entry>
  
  <entry>
    <title>How to use var_dump and print_r into Cakephp</title>
    <link href="https://kisky3.github.io/2021/02/05/AboutCakephp/"/>
    <id>https://kisky3.github.io/2021/02/05/AboutCakephp/</id>
    <published>2021-02-05T01:14:41.000Z</published>
    <updated>2021-09-18T15:02:06.878Z</updated>
    
    <content type="html"><![CDATA[<p>如何在Cakephp里使用var_dump和print_r</p><a id="more"></a><h3 id="var-dump"><a href="#var-dump" class="headerlink" title="var_dump"></a>var_dump</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(参数)</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">      $data = 70;</span><br><span class="line">      var_dump($data);</span><br><span class="line">    ?&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="./1.png" style="width: 500px"></p><p>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">      $data = &quot;abcde&quot;;</span><br><span class="line">      var_dump($data);</span><br><span class="line">    ?&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="./2.png" style="width: 500px"></p><p>数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">      $data = array(&quot;one&quot;,2,3,&quot;four&quot;);</span><br><span class="line">      var_dump($data);</span><br><span class="line">    ?&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><img src="./3.png" style="width: 500px"><h1 id="与print-r的不同"><a href="#与print-r的不同" class="headerlink" title="与print_r的不同"></a>与print_r的不同</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">      $data = array(&quot;one&quot;,2,3,&quot;four&quot;);</span><br><span class="line">      var_dump($data);</span><br><span class="line">      echo &quot;&lt;br /&gt;&quot;;</span><br><span class="line">      print_r ($data);</span><br><span class="line">    ?&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><img src="./4.png" style="width: 500px">第一行为var_dump的输出内容、第二行为print_r的输出内容。print_r一般只打印内容。<hr><p>当是写在view(tpl)里面的时候，可以用下面的写法直接在view里显示数列的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;$array|@debug_print_var&#125;</span><br><span class="line">&#123;$array|@print_r&#125;</span><br><span class="line">&#123;$array|@var_dump&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在Cakephp里使用var_dump和print_r&lt;/p&gt;
    
    </summary>
    
      <category term="Back-end Knowledge" scheme="https://kisky3.github.io/categories/Back-end-Knowledge/"/>
    
    
      <category term="php" scheme="https://kisky3.github.io/tags/php/"/>
    
      <category term="cakephp" scheme="https://kisky3.github.io/tags/cakephp/"/>
    
  </entry>
  
</feed>
